#!/bin/bash
#[of]:comments
#[of]:mouse movements
#[c]mouse drag and drop
#[c]on mouse down record object and position of down event
#[c]  on mouseDrag
#[c]    generate drag mp(message package) i.e. filename/url/etc.
#[c]    on mouse up send mp to object that received the mouseUp event via a mouseDrop 
#[c]  remove mouse down event data
#[cf]
#[c]
#[of]:separate refresh events
#[c]add individual control screen updates
#[c]  already exist if $(o).refresh is called on a control object
#[c]    however most controls don't have code to erase that block of screen first
#[c]  if refresh called on a screen/window all children of that screen/window are updated
#[cf]
#[c]
#[c]
#[c]implement layer selection
#[c]  all objects default to layer 0 (the lowest layer)
#[c]  
#[c]
#[c]build
#[c]  listbox
#[c]    can contain check-boxes(1 or more selections) or circle-selectors(only 1 selection)
#[c]  dropdown
#[c]    like any other type of object, but it must always be draw above all other object
#[c]  textbox
#[c]    a textbox implies the ability to edit text
#[c]
#[c]modify
#[c]  label - perhaps rename all button references to label
#[c]    a button is just a label (usually with a border drawn) with key/mouse events tagged to it.
#[c]
#[c]
#[of]:notes
#[c]If you are displaying text, that is, there is no user input...use a label.
#[c]If you are trying to get user input, use a textbox.
#[c]
#[cf]
#[cf]
#[of]:screenCore
#[of]:description
#[c]screen object base object
#[cf]
#[of]:class meta
screenCore_cm_extends=
#[cf]
#[of]:class methods
function screenCore.classconstructor {
#[c]object
#[of]:  includes
  include hash
  include referenceid
#[cf]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    class data

#[cf]
  "
}
#[cf]
#[of]:static methods
function screenCore.staticconstructor {
  typeset ${omv}method
#[of]:  drawBorder {
IFS='' read -r -d '' ${omv}method <<'EOF'
drawBorder {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}line  ${omv}h ${omv}v  ${omv}tl_br ${omv}tr_bl ${omv}index
    case ${q}${d}{${ov}borderStyle}${q} in
      1)
        ${omv}h='-'
        ${omv}v='|'
        ${omv}tl_br='/'
        ${omv}tr_bl='\'
        ;;
      *)
        ${omv}h='*'
        ${omv}v='*'
        ${omv}tl_br='*'
        ${omv}tr_bl='*'
        ;;
    esac

#[of]:    draw top border
    ${o}.setcursorxy 0 0
    printf -v ${omv}line ${q}%${d}((${ov}width-2))s${q} ${q}${q};echo -n ${q}${d}{${omv}tl_br}${d}{${omv}line// /${d}{${omv}h}}${d}{${omv}tr_bl}${q}
#[cf]
#[of]:    draw left border
    ${o}.setcursorxy 0 1
    printf -v ${omv}line '%*s' $((${ov}height-3));{ echo -n ${q}${d}{${omv}v}${q};echo -en ${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}; }
#[cf]
#[of]:    draw right border
#[c]    ${o}.setcursorxy ${d}((${ov}width-1)) 1
#[c]    printf -v ${omv}line '%*s' $((${ov}height-3));{ echo -n ${q}${d}{${omv}v}${q};echo -en ${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}; }

    for ((${omv}index=1;${omv}index<${ov}height-1;${omv}index++)) ; do
      ${o}.setcursorxy $((${ov}width-1)) ${d}{${omv}index}
      echo -n ${q}${d}{${omv}v}${q}
    done

#[cf]
#[of]:    draw bottom border
    ${o}.setcursorxy 0 ${d}((${ov}height-1))
    printf -v ${omv}line ${q}%${d}((${ov}width-2))s${q} ${q}${q};echo -n ${q}${d}{${omv}tr_bl}${d}{${omv}line// /${d}{${omv}h}}${d}{${omv}tl_br}${q}
#[cf]

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  runEventAction {
IFS='' read -r -d '' ${omv}method <<'EOF'
runEventAction {
#[c]object
#[c]somehow consume ${omv}startx ${omv}starty ${omv}x ${omv}y with callout
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectName ${omv}action
    if ${o}.getEventAction ${omv}objectName ${omv}action ! ! ${q}${d}1${q} ; then
      trap ${q}echo TRAPed signal${q} INT
      eval ${q}${d}{${omv}action}${q}
      trap - INT
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setcursorxy {
IFS='' read -r -d '' ${omv}method <<'EOF'
setcursorxy {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}x ${omv}y
    ${omv}x=${d}1
    ${omv}y=${d}2
    echo -en ${q}\\\\033[${d}((${ov}topOffset+1+${omv}y));${d}((${ov}leftOffset+1+${omv}x))H${q}
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenCore.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  bindEventAction
m=bindEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset _i
  for _i in ${q}${d}{@:1:${d}#-1}${q} ; do
    ${ov}inputEventActions.setkey ${q}${d}{_i}${q} ${q}${d}{@: -1}${q}
  done
}"
#[cf]
#[of]:  getEventAction
m=getEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
  ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}5${q}
}"
#[cf]
#[of]:  delEventAction
m=delEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}inputEventActions.delkey ${q}${d}1${q}
}"
#[cf]
#[of]:  styleSetReverse
m=styleSetReverse
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  echo -en ${q}\\033[7m${q}
}"
#[cf]
#[of]:  styleSetNormal
m=styleSetNormal
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  echo -en ${q}\\033[0m${q}
}"
#[cf]
#[of]:  public settable object data
  newPublicVar height width title drawBorder borderStyle
#[cf]
  eval "
#[of]:    object data
newvar ${ov}leftOffset ${ov}topOffset
new hash ${ov}inputEventActions

${ov}leftOffset=0
${ov}topOffset=0

${ov}drawBorder=0
${ov}borderStyle=0

${ov}width=${q}${d}{1:-0}${q}
${ov}height=${q}${d}{2:-0}${q}
#[cf]
  "
}
#[cf]
#[cf]
#[of]:screenManage
#[of]:description
#[c]screen object base object
#[cf]
#[of]:class meta
screenManage_cm_extends=screenCore
#[cf]
#[of]:static methods
function screenManage.staticconstructor {
  typeset ${omv}method
#[of]:  bindObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
bindObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}left ${omv}top ${omv}width ${omv}height
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}
    ${omv}left=${q}${d}2${q}
    ${omv}top=${q}${d}3${q}
    ${d}{${omv}objectName}.getHeight ${omv}height
    ${d}{${omv}objectName}.getWidth ${omv}width

    ${ov}objectIdPool.getid ${omv}objectId

    ${ov}objectNames[${d}{${omv}objectId}]=${q}${d}{${omv}objectName}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+0))]=${q}${d}{${omv}left}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+1))]=${q}${d}((${omv}left + ${omv}width-1))${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+2))]=${q}${d}{${omv}top}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+3))]=${q}${d}((${omv}top + ${omv}height-1))${q}
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  resizeObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
resizeObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}left ${omv}top ${omv}width ${omv}height
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}
    ${d}{${omv}objectName}.getHeight ${omv}height
    ${d}{${omv}objectName}.getWidth ${omv}width

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        ${omv}left=${q}${d}{${ov}objectPositions[${d}((4*${omv}objectId+0))]}${q}
        ${omv}top=${q}${d}{${ov}objectPositions[${d}((4*${omv}objectId+2))]}${q}
        ${ov}objectPositions[${d}((4*${omv}objectId+1))]=${q}${d}((${omv}left + ${omv}width -1))${q}
        ${ov}objectPositions[${d}((4*${omv}objectId+3))]=${q}${d}((${omv}top + ${omv}height -1))${q}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  delObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
delObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        unset ${ov}objectNames[${d}{${omv}objectId}]
        ${ov}objectIdPool.delid ${d}{${omv}objectId}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[c]
#[of]:  focusAdd {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusAdd {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}objectName ${omv}objectLocated ${omv}focusListKey 
    ${omv}objectLocated=0
    ${omv}objectName=${q}${d}1${q}

    #check if object is already in the focus list    
    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q} ]] ; then
        return 0
      fi
    done

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        ${omv}objectLocated=1
        break
      fi
    done
    if ((${omv}objectLocated)) ; then
      apush ${ov}focusList ${q}${d}{${omv}objectId}${q}
    else
      die 1 ${q}${c}.${d}{FUNCNAME[1]##*.} -- the control object ${d}{${omv}objectName} is not bound to ${o}${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusDel {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusDel {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return
    typeset ${omv}focusListKey ${omv}objectName ${omv}objectLocated
    ${omv}objectName=${q}${d}1${q}
    
    for ${omv}focusListKey in ${q}${d}{!${ov}focusList[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]##*_}${q} ]] ; then
        unset ${ov}focusList[${d}{${omv}focusListKey}]
        ${ov}focusList=( ${q}${d}{${ov}focusList[@]}${q} )
        break
      fi
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenManage.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    object data

#[cf]
  "
}
#[cf]
#[cf]
#[of]:screen
#[of]:description
#[c]screen
#[c]  size: grab from terminal
#[c]  handle all Key/Mouse Events
#[c]    button events happen either on the screen or in a window
#[c]  window
#[c]    button
#[c]    slider
#[c]    filebrowser
#[cf]
#[of]:class meta
screen_cm_extends=screenManage
#[cf]
#[of]:class methods
function screen.classconstructor {
#[c]object
#[of]:  includes

#[cf]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    function ${c}.mouseEnable {
function ${c}.mouseEnable {
  stty -echo
  if [[ ${q}${d}1${q} == ${q}-d${q} ]] ; then
    echo -en '\e[?1002;1006;1015h'
  else
    echo -en '\e[?1000;1006;1015h'
  fi
}
#[cf]
#[of]:    function ${c}.mouseDisable {
function ${c}.mouseDisable {
  stty echo
  echo -en '\e[?1000;1001;1002;1003;1006;1015l'
}
#[cf]
#[of]:    function ${c}.stringLength {
function ${c}.stringLength {
  if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
    echo ${d}(wc -L <<< ${q}${d}2${q})
  else
    eval ${q}${d}1=\\${d}(wc -L <<< \\${q}\\${d}2\\${q})${q}
  fi
}
#[cf]
#[of]:    function ${c}.trimString {
function ${c}.trimString {
  typeset _s
  _s=${q}${d}3${q}
  while ((${d}(wc -L <<< ${q}${d}{_s}${q})>${d}{2}));do _s=${q}${d}{_s%?}${q};done
  if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
    echo ${q}${d}{_s}${q}
  else
    eval ${d}1=\\${q}\\${d}{_s}\\${q}
  fi

}
#[cf]
#[of]:    class data
newvar ${cv}height ${cv}width
#[cf]
    ${c}.calcScreenSize
  "
}
#[cf]
#[of]:static methods
function screen.staticconstructor {
  typeset ${omv}method
#[of]:  open {
IFS='' read -r -d '' ${omv}method <<'EOF'
open {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}key ${omv}mouse
    typeset ${omv}mouseEvent ${omv}mouseEvents ${omv}mouseButtonId ${omv}mouseButtonName
    typeset ${omv}mouseXStart ${omv}mouseYStart ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentRelX ${omv}currentRelY ${omv}relX ${omv}relY
    typeset ${omv}mouseButtonState ${omv}shift ${omv}alt ${omv}ctrl
    typeset ${omv}objectName ${omv}objectId
    typeset ${omv}triggerId

    ${omv}refreshInterval=${q}${d}{${ov}refreshInterval}${q}

    ${o}.calcScreenSize
    ${o}.focusListBuild
    ${o}.focusTriggerEnterEvent
    clear
    ${o}.refresh
    ${c}.mouseEnable -d
#[of]:    key process loop
    while : ; do
      ((${ov}flagExit)) && {
        ${ov}flagExit=0
        break
      }
      read -s -N 1 -r ${d}{${ov}tickIntervalSeconds:+-t ${d}{${ov}tickIntervalSeconds}} ${omv}key || {
        ((${ov}tick+=1))
        ((${ov}tick>${ov}tickMax)) && ${ov}tick=0

        for ${omv}triggerId in ${q}${d}{!${ov}timerTriggerIdList[@]}${q} ; do
          ((${ov}tick%${ov}tickTriggers[${d}((${omv}triggerId*3))]==0)) && {
            ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+1))]}.runEventAction ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+2))]}
          }
        done

        ((${ov}refreshInterval>0)) && ((${ov}tick%${ov}refreshInterval==0)) && ${o}.refresh
      }
      case ${q}${d}{${omv}key}${q} in
#[of]:        escaped keys
        ${d}'\e')
          read -s -N 2 -r -t .1 ${omv}key || {
#[of]:            esc
#[c]            esc itself is just a single char
#[c]            if read timeout is reached the key must be esc
            ${omv}key=esc
            ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
            ${o}.processEvent \
              ${q}${d}{${omv}objectName}${q} \
              ${q}${d}{${omv}key}${q} \
              0 0 \
              0 0 || \
            echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
            continue
#[cf]
          }
          [[ ${q}${d}{${omv}key}${q} == '[1' ]] && read -s -N 3 -r -t .1 ${omv}key
          case ${q}${d}{${omv}key}${q} in
#[of]:            mouse
            '[<')
              ${omv}mouseButtonId=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseButtonId=${q}${d}{${omv}mouseButtonId}${d}{${omv}key}${q}
              done
              ${omv}mouseX=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseX=${q}${d}{${omv}mouseX}${d}{${omv}key}${q}
              done
              ${omv}mouseY=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [ -z ${q}${d}{${omv}key#[Mm]}${q} ] && break
                ${omv}mouseY=${q}${d}{${omv}mouseY}${d}{${omv}key}${q}
              done
              [[ ${q}${d}{${omv}key}${q} == ${q}M${q} ]] && ${omv}mouseButtonState=${q}Down${q} || ${omv}mouseButtonState=${q}Up${q}
              ((${omv}mouseX--))
              ((${omv}mouseY--))

#[c]left middle right scroll_Up scroll_Down
#[c]shift alt ctrl

              (( (${omv}mouseButtonId & 4 )==4  )) && ${omv}shift=${q}Shift${q} || ${omv}shift=${q}${q}
              (( (${omv}mouseButtonId & 8 )==8  )) && ${omv}alt=${q}Alt${q}     || ${omv}alt=${q}${q}
              (( (${omv}mouseButtonId & 16)==16 )) && ${omv}ctrl=${q}Ctrl${q}   || ${omv}ctrl=${q}${q}
              (( (${omv}mouseButtonId & 32)==32 )) && ${omv}mouseButtonState=${q}Drag${q}
              case ${q}${d}((${omv}mouseButtonId & 67))${q} in
                 0) ${omv}mouseButtonName=${q}Left${q}   ;;&
                 1) ${omv}mouseButtonName=${q}Middle${q} ;;&
                 2) ${omv}mouseButtonName=${q}Right${q}  ;;&
                64) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Up${q}    ;;
                65) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Down${q}  ;;
                 *) case ${q}${d}{${omv}mouseButtonState}${q} in
                      Down)
                        ${ov}previousMouseButtonName=${q}${d}{${omv}mouseButtonName}${q}
                        ${ov}previousMouseX=${q}${d}{${omv}mouseX}${q}
                        ${ov}previousMouseY=${q}${d}{${omv}mouseY}${q}
                        ;;
                      Up)
                        [[  ${q}${d}{${ov}previousMouseButtonName}${q} = ${q}${d}{${omv}mouseButtonName}${q} &&
                            ${q}${d}{${ov}previousMouseX}${q} = ${q}${d}{${omv}mouseX}${q} &&
                            ${q}${d}{${ov}previousMouseY}${q} = ${q}${d}{${omv}mouseY}${q} ]] && \
                          aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}Click${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}
                        ;;
                    esac
                    ;;
              esac
              aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}${d}{${omv}mouseButtonState}${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}

#[c]              object on screen has TOPxLEFT and WIDTHxHEIGHT
#[c]                button Down event
#[c]                  -if xy no longer on the current object it is a drag-drop operation
#[c]                  setCurrentScreenObject buttonID/textBoxID/windowID/etc...
#[c]                  screen.objectID.sendEvent mouse_Left_Down x-left y-top
#[c]                button Up event
#[c]                  screen.objectID.sendEvent mouse_Left_Up objectID sx-left sy-top x-left y-top
#[c]                
#[c]              
#[c]              for objectID in screen_objects do
#[c]                if top<y<top+height && left<x<left+width ; then
#[c]                  if [[ ${q}${d}{${omv}mouseButtonName}${q} == ${q}scroll${q} || ${q}${d}{${omv}mouseButtonState}${q} == ${q}Down${q} ]] && setCurrentScreenObject=${objectID}
#[c]                  screen.sendEvent objectID mouse_Left_Down x-left y-top
#[c]                  break
#[c]                fi
#[c]              done

              ${omv}relX=${d}{${omv}mouseX}
              ${omv}relY=${d}{${omv}mouseY}
              ${omv}objectName=${q}${q}
              for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
                if  (( ${ov}objectPositions[4*${omv}objectId+0] <= ${omv}mouseX &&
                    ${omv}mouseX <= ${ov}objectPositions[${d}((4*${omv}objectId+1))] &&
                   ${ov}objectPositions[4*${omv}objectId+2] <= ${omv}mouseY &&
                   ${omv}mouseY <= ${ov}objectPositions[4*${omv}objectId+3] ))
                then
                  ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q}
                  ${omv}relX=${d}(( ${omv}mouseX - ${ov}objectPositions[4*${omv}objectId+0] ))
                  ${omv}relY=${d}(( ${omv}mouseY - ${ov}objectPositions[4*${omv}objectId+2] ))
#[c]                  echo ${q}${d}{${omv}objectName} ${d}{${ov}objectPositions[4*${omv}objectId+0]} ${d}{${ov}objectPositions[4*${omv}objectId+1]} ${d}{${ov}objectPositions[4*${omv}objectId+2]} ${d}{${ov}objectPositions[4*${omv}objectId+3]}${q}
                  break
                fi
              done

#[c]###write some code that disables event actions and just shows mouse events
#[c]###be sure the code shows screen object calls as well
              ((gl_debug>0)) && echo ${q}s - ${d}{!${ov}objectPositions[@]} | ${d}{${ov}objectPositions[@]} -- ${d}{${omv}objectName:-${o}} ${d}{${omv}mouseEvent} ${d}{${omv}relX} ${d}{${omv}relY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}${q}

              while ashift ${omv}mouseEvent ${omv}mouseEvents ; do
                ${o}.processEvent \
                  ${q}${d}{${omv}objectName:-${o}}${q} \
                  ${q}${d}{${omv}mouseEvent}${q} \
                  ${q}${d}{${omv}relX}${q} ${q}${d}{${omv}relY}${q} \
                  ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
              done
              ;;
#[cf]
#[of]:            shift up)
            '[a'|';2A')
              ${omv}key=shiftUp
              ;;&
#[cf]
#[of]:            shift down)
            '[b'|';2B')
              ${omv}key=shiftDown
              ;;&
#[cf]
#[of]:            shift left)
            '[d'|';2D')
              ${omv}key=shiftLeft
              ;;&
#[cf]
#[of]:            shift right)
            '[c'|';2C')
              ${omv}key=shiftRight
              ;;&
#[cf]
#[of]:            alt up)
            ';3A')
              ${omv}key=altUp
              ;;&
#[cf]
#[of]:            alt down)
            ';3B')
              ${omv}key=altDown
              ;;&
#[cf]
#[of]:            alt left)
            ';3D')
              ${omv}key=altLeft
              ;;&
#[cf]
#[of]:            alt right)
            ';3C')
              ${omv}key=altRight
              ;;&
#[cf]
#[of]:            ctrl up)
            ';5A')
              ${omv}key=ctrlUp
              ;;&
#[cf]
#[of]:            ctrl down)
            ';5B')
              ${omv}key=ctrlDown
              ;;&
#[cf]
#[of]:            ctrl left)
            ';5D')
              ${omv}key=ctrlLeft
              ;;&
#[cf]
#[of]:            ctrl right)
            ';5C')
              ${omv}key=ctrlRight
              ;;&
#[cf]
#[of]:            up)
            '[A')
              ${omv}key=up
              ;;&
#[cf]
#[of]:            down)
            '[B')
              ${omv}key=down
              ;;&
#[cf]
#[of]:            left)
            '[D')
              ${omv}key=left
              ;;&
#[cf]
#[of]:            right)
            '[C')
              ${omv}key=right
              ;;&
#[cf]
#[of]:            shift tab)
            '[Z')
              ${omv}key=shiftTab
              ;;&
#[cf]
#[of]:            page up)
            '[5')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageUp
              ;;&
#[cf]
#[of]:            page down)
            '[6')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageDown
              ;;&
#[cf]
#[of]:            *)
            *)
              ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
              ${o}.processEvent \
                ${q}${d}{${omv}objectName}${q} \
                ${q}${d}{${omv}key}${q} \
                0 0 \
                0 0 || \
              echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
              ;;
#[cf]
          esac
          ;;
#[cf]
#[of]:        enter)
        '
')
          ${omv}key=enter
          ;;&
#[cf]
#[of]:        tab)
        '	')
          ${omv}key=tab
          ;;&
#[cf]
#[of]:        tick)
        '')
          ;;
#[cf]
#[of]:        *)
        *)
          ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
          ${o}.processEvent \
            ${q}${d}{${omv}objectName}${q} \
            ${q}${d}{${omv}key}${q} \
            0 0 \
            0 0 || \
          echo ${q}ascii ---${d}{${omv}key}---chr---${d}{${omv}objectName:-${o}}${q}
          ;;
#[cf]
      esac
    done
#[cf]
    ${c}.mouseDisable

    clear
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((gl_debug>0)) && return
    typeset ${omv}objectId ${omv}left ${omv}top
    
    clear

    ${o}.runEventAction refresh

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
    ${omv}left=${d}{${ov}objectPositions[4*${omv}objectId+0]}
    ${omv}top=${d}{${ov}objectPositions[4*${omv}objectId+2]}
      ${o}.setcursorxy ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.refresh \
        ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q} \
        ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} \
        ${q}${d}{${ov}focusListMerged[${ov}focusedObjectIndex]}${q}
    done
    ${o}.setcursorxy 0 0

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  timerTriggerAdd {
IFS='' read -r -d '' ${omv}method <<'EOF'
timerTriggerAdd {
#[c]object objectname event_to_trigger tick_devisor
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}triggerId

    ${ov}timerTriggerIdPool.getid ${omv}triggerId
    ${ov}timerTriggerIdList[${d}{${omv}triggerId}]=''

    ${ov}tickTriggers[${d}((${omv}triggerId*3))]=${q}${d}3${q}
    ${ov}tickTriggers[${d}((${omv}triggerId*3+1))]=${q}${d}1${q}
    ${ov}tickTriggers[${d}((${omv}triggerId*3+2))]=${q}${d}2${q}
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  timerTriggerDel {
IFS='' read -r -d '' ${omv}method <<'EOF'
timerTriggerDel {
#[c]object objectname event_to_trigger
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}triggerName ${omv}triggerId

    ${omv}triggerName=${q}${d}1_${d}2${q}

    for ${omv}triggerId in ${q}${d}{!${ov}timerTriggerIdList[@]}${q} ; do
      if [[ ${q}${d}{${omv}triggerName}${q} = ${q}${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+1))]}_${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+2))]}${q} ]] ; then
        unset ${ov}timerTriggerIdList[${d}{${omv}triggerId}]
        ${ov}timerTriggerIdPool.delid ${d}{${omv}triggerId}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  processEvent {
IFS='' read -r -d '' ${omv}method <<'EOF'
processEvent {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectName ${omv}event
    typeset ${omv}relX ${omv}relY ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentObjectName ${omv}currentRelX ${omv}currentRelY
  
    ${omv}objectName=${q}${d}1${q}
    ${omv}event=${q}${d}2${q}
    ${omv}relX=${q}${d}3${q}
    ${omv}relY=${q}${d}4${q}
    ${omv}mouseX=${q}${d}5${q}
    ${omv}mouseY=${q}${d}6${q}

    ${omv}currentRelX=${q}${d}{${omv}relX}${q}
    ${omv}currentRelY=${q}${d}{${omv}relY}${q}
    ${d}{${omv}objectName:-${o}}.getEventAction \
      ${omv}currentObjectName ! \
      ${omv}currentRelX ${omv}currentRelY \
      ${q}${d}{${omv}event}${q} \
      ${q}${d}{${omv}relX}${q} ${q}${d}{${omv}relY}${q} \
      ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q} && {
          if ! ((gl_debug>1)) ; then
            ${c}.mouseDisable
            ((gl_debug>0)) && echo ${d}{${omv}currentObjectName}.runEventAction \
              ${q}${d}{${omv}event}${q} \
              ${q}${d}{${omv}currentRelX}${q} ${q}${d}{${omv}currentRelY}${q} \
              ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
            ${d}{${omv}currentObjectName}.runEventAction \
              ${q}${d}{${omv}event}${q} \
              ${q}${d}{${omv}currentRelX}${q} ${q}${d}{${omv}currentRelY}${q} \
              ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
            #${o}.calcScreenSize
            ${o}.refresh
            ${c}.mouseEnable -d
          else
            echo ${d}{${omv}currentObjectName}.runEventAction ${q}${d}{${omv}event}${q} ${d}{${omv}currentRelX} ${d}{${omv}currentRelY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}
          fi
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  focusListBuild {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusListBuild {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}objectName ${omv}focusListKey ${omv}focusList
    unset ${ov}focusListMerged

    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q}
      if isfnset ${d}{${omv}objectName}.focusList ; then
        ${d}{${omv}objectName}.focusList ${omv}focusList ${q}${d}{${omv}objectName}${q}
        apush ${ov}focusListMerged ${q}${d}{${omv}focusList[@]}${q}
      else
        apush ${ov}focusListMerged ${q}${d}{${omv}objectName}${q}
      fi
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusSelectByName {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusSelectByName {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew
    typeset ${omv}focusListKey ${omv}objectName ${omv}objectLocated
    ${omv}objectLocated=0
    ${omv}objectName=${q}${d}1${q}

    ${o}.focusListBuild
    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    for ${omv}focusListKey in ${q}${d}{!${ov}focusListMerged[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}focusListMerged[${d}{${omv}focusListKey}]##*_}${q} ]] ; then
        ${omv}objectLocated=1
        ${ov}focusedObjectIndex=${d}{${omv}focusListKey}
        break
      fi
    done
    if ! ((${omv}objectLocated)) ; then
      die 1 ${q}${c}.${d}{FUNCNAME[1]##*.} -- the control object ${d}{${omv}objectName} is not in the ${o} focusList${q}
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    
    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusTriggerEnterEvent {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusTriggerEnterEvent {
#[c]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 0

    typeset ${omv}objectName
    ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    ${o}.processEvent ${q}${d}{${omv}objectName}${q} ${q}focusEnter${q} 0 0 0 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusTriggerExitEvent {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusTriggerExitEvent {
#[c]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 0

    typeset ${omv}objectName
    ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    ${o}.processEvent ${q}${d}{${omv}objectName}${q} ${q}focusExit${q} 0 0 0 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusNext {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusNext {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 1

    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew ${omv}objectName

    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if ((${ov}focusedObjectIndex>=${d}{#${ov}focusListMerged[@]}-1)) ; then
      ${ov}focusedObjectIndex=0
    else
      ((${ov}focusedObjectIndex++))
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    
    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[c]
#[c]focus needs to be by tree connection not by object name
#[c]screen + window need to tell the object it has focus on render
#[c]
#[c]crawl the tree and gather object IDs
#[c]how to represent this? rest-ish
#[c]
#[c]
#[c]
#[c]if currenly focused object is a window
#[c]  call w.finc || f.inc
#[c]
#[c]
#[c]s1 ---\------1-fb--1-fb
#[c]       \ 
#[c]        \----2-pl--\--1-cl--\-----1-b1
#[c]         \          \-2-bf   \----2-b2
#[c]          \                   \---3-b3
#[c]           \-3-lb--1-b1        \--4-b4
#[c]                                \-5-sl
#[c]
#[c]1-1
#[c]2-1-1
#[c]2-1-2
#[c]2-1-3
#[c]2-1-4
#[c]2-1-5
#[c]2-2
#[c]3-1
#[c]
#[c]
#[c]
#[c]s1.focusAdd mediaPlayerBox
#[c]  mediaPlayerBox.focusAdd playerControls
#[c]    playerControls.focusAdd mediaPlayerButton1
#[c]  mediaPlayerBox.focusAdd bf
#[c]
#[c]a 0
#[c]b 0
#[c]a 1
#[c]b 0
#[c]a 1
#[cf]
#[of]:  focusPrevious {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusPrevious {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 1

    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew ${omv}objectName

    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if ((${ov}focusedObjectIndex==0)) ; then
      ((${ov}focusedObjectIndex=${d}{#${ov}focusListMerged[@]}-1))
    else
      ((${ov}focusedObjectIndex--))
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  calcscreensize {
IFS='' read -r -d '' ${omv}method <<'EOF'
calcScreenSize {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    set -- ${d}(stty size 2>/dev/null)
    ${ov}height=${d}1
    ${ov}width=${d}2
    [[ -z ${q}${d}{${ov}height}${q} ]] && {
      ${ov}height=24
      ${ov}width=80
    }
#[c]    echo ${d}{${ov}height} ${d}{${ov}width}
#[c]    read -n 1
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setScreenHeight {
IFS='' read -r -d '' ${omv}method <<'EOF'
setScreenHeight {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    #to get the resize command
    #sudo apt install xterm
    typeset ${omv}height
    
    if isset TERM && [[ -z ${q}${d}{TERM##xterm*}${q} ]] && which resize &>/dev/null ; then
      ${omv}height=${d}1
      resize -s ${d}{${omv}height} ${d}{${ov}width} &>/dev/null || return 1
      ${ov}height=${d}{${omv}height}
    else
      return 1
    fi
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setScreenWidth {
IFS='' read -r -d '' ${omv}method <<'EOF'
setScreenWidth {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    #to get the resize command
    #sudo apt install xterm
    typeset ${omv}width
  
    if isset TERM && [[ -z ${q}${d}{TERM##xterm*}${q} ]] && which resize &>/dev/null ; then
      ${omv}width=${d}1
      resize -s ${d}{${ov}height} ${d}{${omv}width} &>/dev/null || return 1
      ${ov}width=${d}{${omv}width}
    else
      return 1
    fi
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screen.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setRefreshInterval
m=setRefreshInterval
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  if [[ -z ${q}${d}1${q} ]] ; then
    ${ov}refreshInterval=${q}0${q}
  else
    ${ov}refreshInterval=${q}${d}1${q}
  fi
}"
#[cf]
#[of]:  setTickInterval
m=setTickInterval
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset _precision
  if [[ -z ${q}${d}1${q} || ${q}${d}1${q} = 0 ]] ; then
    ${ov}tickIntervalSeconds=${q}${q}
  else
    _precision=100
    ${ov}tick=0
    ${ov}tickInterval=${q}${d}1${q}
    ${ov}tickMax=${d}((_precision*1000/${ov}tickInterval*${ov}cycleLength/_precision))
    printf -v ${ov}tickIntervalSeconds '%04d' ${q}${d}{${ov}tickInterval}${q}
    ${ov}tickIntervalSeconds=${q}${d}{${ov}tickIntervalSeconds%???}.${d}{${ov}tickIntervalSeconds#${d}{${ov}tickIntervalSeconds%???}}${q}
  fi
}"
#[cf]
#[of]:  exit
m=exit
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}flagExit=1
}"
#[cf]
  eval "
#[of]:    object data
newvar ${ov}objectPositions ${ov}objectNames
newvar ${ov}previousMouseButtonName ${ov}previousMouseX ${ov}previousMouseY

new hash ${ov}objects

new referenceid ${ov}objectIdPool

newvar ${ov}flagExit
${ov}flagExit=0

newvar ${ov}focusedObjectIndex ${ov}focusedObjectName ${ov}focusList ${ov}focusListMerged
${ov}focusedObjectIndex=0


typeset _precision
newvar ${ov}tick ${ov}tickInterval ${ov}cycleLength ${ov}tickMax ${ov}tickIntervalSeconds
newvar ${ov}timerTriggerIdList ${ov}tickTriggers
new referenceid ${ov}timerTriggerIdPool
_precision=100
${ov}tick=0
${ov}tickInterval=1000
${ov}cycleLength=${d}((24*60*60))

${ov}tickMax=${d}((_precision*1000/${ov}tickInterval*${ov}cycleLength/_precision))
printf -v ${ov}tickIntervalSeconds '%04d' ${q}${d}{${ov}tickInterval}${q}
${ov}tickIntervalSeconds=${q}${d}{${ov}tickIntervalSeconds%???}.${d}{${ov}tickIntervalSeconds#${d}{${ov}tickIntervalSeconds%???}}${q}

newvar ${ov}refreshInterval
${ov}refreshInterval=10

#[cf]
  "
}
#[cf]
#[cf]
#[of]:window
#[of]:class meta
window_cm_extends=screenManage
#[cf]
#[of]:static methods
function window.staticconstructor {
  typeset ${omv}method
#[of]:refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}left ${omv}top ${omv}width ${omv}height ${omv}parentFocusKey
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${omv}parentFocusKey=${q}${d}3${q}
    ${omv}focusedObject=${q}${d}4${q}
    
    ${o}.runEventAction refresh

    ((${ov}drawBorder)) && ${o}.drawBorder

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      ${omv}left=${d}{${ov}objectPositions[4*${omv}objectId+0]}
      ${omv}top=${d}{${ov}objectPositions[4*${omv}objectId+2]}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.getWidth ${omv}width
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.getHeight ${omv}height
      if (( (${omv}left+${omv}width) > ${ov}width || (${omv}top+${omv}height) > ${ov}height )) ; then
        die 1 ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]} is out of bounds of ${o}${q}
      fi

      ${o}.setcursorxy ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.refresh \
        ${q}${d}((${ov}leftOffset+${omv}left))${q} \
        ${q}${d}((${ov}topOffset+${omv}top))${q} \
        ${q}${d}{${omv}parentFocusKey}_${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} \
        ${q}${d}{${omv}focusedObject}${q}
    done
    ${o}.setcursorxy 1 1

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:getEventAction {
IFS='' read -r -d '' ${omv}method <<'EOF'
getEventAction {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}mouseEvent ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentRelX ${omv}currentRelY ${omv}relX ${omv}relY
    typeset ${omv}objectName ${omv}objectId ${omv}action
#[c]    echo \"\$@\"
    ${omv}mouseEvent=${q}${d}{5}${q}
    ${omv}relX=${q}${d}{6}${q}
    ${omv}relY=${q}${d}{7}${q}

    if [[ -z ${q}${d}{${omv}relX}${q} ]] ; then
      [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
      ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}{${omv}mouseEvent}${q}
      return
    fi

    ${omv}mouseX=${d}{${omv}relX}
    ${omv}mouseY=${d}{${omv}relY}
    ${omv}objectName=${q}${q}
    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if  (( ${ov}objectPositions[4*${omv}objectId+0] <= ${omv}mouseX &&
          ${omv}mouseX <= ${ov}objectPositions[${d}((4*${omv}objectId+1))] &&
         ${ov}objectPositions[4*${omv}objectId+2] <= ${omv}mouseY &&
         ${omv}mouseY <= ${ov}objectPositions[4*${omv}objectId+3] ))
      then
        ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q}
#[c]echo ${q}---|${d}{${ov}objectNames[@]}|---${q}
        ${omv}relX=${d}(( ${omv}mouseX - ${ov}objectPositions[4*${omv}objectId+0] ))
        ${omv}relY=${d}(( ${omv}mouseY - ${ov}objectPositions[4*${omv}objectId+2] ))
#[c]        echo ${q}${d}{${omv}objectName} ${d}{${ov}objectPositions[4*${omv}objectId+0]} ${d}{${ov}objectPositions[4*${omv}objectId+1]} ${d}{${ov}objectPositions[4*${omv}objectId+2]} ${d}{${ov}objectPositions[4*${omv}objectId+3]}${q}
        break
      fi
    done
  
#[c]    ((gl_debug>0)) && 
#[c]    echo ${q}w - ${d}{!${ov}objectPositions[@]} | ${d}{${ov}objectPositions[@]} -- ${o}_${d}{${omv}objectName:---} ${d}{${omv}mouseEvent} ${d}{${omv}relX} ${d}{${omv}relY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}${q}

#[c][[ ${q}${o}_${d}{${omv}objectName}${q} = ${q}fileBrowserBox_fb1${q} ]] && set -xv

    if [[ -n ${q}${d}{${omv}objectName}${q} ]] ; then
#[c]      echo ${d}{${omv}objectName}.getEventAction ${q}${d}1${q} ${q}${d}2${q} ${omv}currentRelX ${omv}currentRelY ${q}${d}{${omv}mouseEvent}${q} ${d}{${omv}relX} ${d}{${omv}relY} || return 1
      ${d}{${omv}objectName}.getEventAction ${q}${d}1${q} ${q}${d}2${q} ${omv}currentRelX ${omv}currentRelY ${q}${d}{${omv}mouseEvent}${q} ${d}{${omv}relX} ${d}{${omv}relY} || return 1
      [[ ${q}${d}3${q} != ${q}!${q} ]] && eval ${d}3=\\${q}\\${d}{${omv}currentRelX:-\\${d}{${omv}relX}}\\${q}
      [[ ${q}${d}4${q} != ${q}!${q} ]] && eval ${d}4=\\${q}\\${d}{${omv}currentRelY:-\\${d}{${omv}relY}}\\${q}
      return 0
    else
      [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
      ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}{${omv}mouseEvent}${q}
      [[ ${q}${d}3${q} != ${q}!${q} ]] && eval ${d}3=\\${q}\\${d}{${omv}relX}\\${q}
      [[ ${q}${d}4${q} != ${q}!${q} ]] && eval ${d}4=\\${q}\\${d}{${omv}relY}\\${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:focusList {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusList {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}entry ${omv}objectId ${omv}objectName ${omv}focusListKey ${omv}focusList ${omv}focusListMerged
    typeset ${omv}parentFocusKey
    ${omv}parentFocusKey=${q}${d}2${q}

    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q}
      if isfnset ${d}{${omv}objectName}.focusList ; then
        ${d}{${omv}objectName}.focusList ${omv}focusList ${q}${d}{${omv}parentFocusKey}_${d}{${omv}objectName}${q}
        for ${omv}entry in ${q}${d}{${omv}focusList[@]}${q} ; do
          apush ${omv}focusListMerged ${q}${d}{${omv}entry}${q}
        done
      else
        apush ${omv}focusListMerged ${q}${d}{${omv}parentFocusKey}_${d}{${omv}objectName}${q}
      fi
    done

    aset ${d}1 ${q}${d}{${omv}focusListMerged[@]}${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function window.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    object data
newvar ${ov}objectPositions
new referenceid ${ov}objectIdPool

${o}.setWidth ${q}${d}{1:-0}${q}
${o}.setHeight ${q}${d}{2:-0}${q}

#[c]${ov}drawBorder=0
#[c]${ov}borderStyle=0

#[cf]
  "
}
#[cf]
#[cf]
#[of]:screenObject
#[of]:description
#[c]screen object base object
#[cf]
#[of]:class meta
screenObject_cm_extends=screenCore
#[cf]
#[of]:static methods
function screenObject.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}hasFocus ${omv}length ${omv}index ${omv}line
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }

    ${o}.runEventAction refresh

    [[ -n ${q}${d}4${q} ]] && {
      [[ ${q}${d}3${q} = ${q}${d}4${q} ]] && ${ov}hasFocus=1 || ${ov}hasFocus=0
    }

    ((${ov}height>2)) && {
      for ((${omv}index=0;${omv}index<${ov}height;${omv}index++)) ; do
        ${o}.setcursorxy 0 ${d}{${omv}index}
        printf ${q}%${d}((${ov}width))s${q} ${q}${q}
      done
      
      ((${ov}drawBorder)) && ${o}.drawBorder
    }

    ((${ov}hasFocus)) && ${o}.styleSetReverse
    
    screen.stringLength ${omv}length ${q}${d}{${ov}title}${q}
#[c]    ${o}.setcursorxy 0 ${d}((${ov}height/2))
#[c]    printf ${q}%${d}((${ov}width))s${q} ${q}${q}
    if ((${ov}txtAlignment)) ; then
      ${o}.setcursorxy 0 ${d}((${ov}height/2))
    else
      ${o}.setcursorxy ${d}((${ov}width/2-${d}{${omv}length}/2)) ${d}((${ov}height/2))
    fi
    echo -n ${q}${d}{${ov}title:0:${d}((${ov}width))}${q}

    ((${ov}hasFocus)) && ${o}.styleSetNormal
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenObject.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  public settable object data
  newPublicVar txtAlignment
#[cf]
  eval "
#[of]:    object data
newvar ${ov}hasFocus

${ov}txtAlignment=0
#[cf]
  "
}
#[cf]
#[cf]
#[of]:button
#[of]:class meta
button_cm_extends=screenObject
#[cf]
#[of]:dynamic methods
function button.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setTitle
m=setTitle
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}title=${q}${d}1${q}

  if ((${ov}width==0)) ; then
    if ((${ov}drawBorder)) && ((${ov}height>2)) ; then
      ${ov}width=${d}((${d}{#${ov}title}+4))
    else
      ${ov}width=${d}{#${ov}title}
    fi
  else
    screen.trimString ${ov}title ${d}{${ov}width} ${q}${d}{${ov}title}${q}
  fi
}"
#[cf]
  eval "
#[of]:    object data
${ov}drawBorder=1
${ov}borderStyle=1
#[cf]
  "
}
#[cf]
#[cf]
#[of]:progressSlider
#[of]:class meta
progressSlider_cm_extends=screenObject
#[cf]
#[of]:static methods
function progressSlider.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}timeSliderLength ${omv}songLength ${omv}songTimePlayed ${omv}songPercentagePlayed
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }

    ${o}.runEventAction refresh

    [[ -n ${q}${d}4${q} ]] && {
      [[ ${q}${d}3${q} = ${q}${d}4${q} ]] && ${ov}hasFocus=1 || ${ov}hasFocus=0
    }

    ! ((${ov}hasFocus)) && ${cmv}timeSlider=${q}${d}{${ov}timeSlider}${q}
    ((${ov}hasFocus)) && ${cmv}timeSlider=${q}${d}{${ov}timeSliderFocused}${q}

    ${omv}timeSliderLength=${d}((${ov}timeSliderLength-3))
    ${omv}songLength=${d}(echo '{ ${q}command${q}: [${q}get_property${q}, ${q}duration${q}] }' | socat - /tmp/mpvsocket 2>/dev/null | grep -oP '${q}data${q}:\\K[^,]+')
    ${omv}songTimePlayed=${d}(echo '{ ${q}command${q}: [${q}get_property${q}, ${q}playback-time${q}] }' | socat - /tmp/mpvsocket 2>/dev/null | grep -oP '${q}data${q}:\\K[^,]+')
    [[ -z ${q}${d}{${omv}songLength}${q} || -z ${q}${d}{${omv}songTimePlayed##*[^[:digit:].]*}${q} ]] && {
      ${o}.setcursorxy 0 0
      echo -n ${q}<00%${d}{${cmv}timeSlider:3:${d}((${omv}timeSliderLength))}>${q}
      return
    }
    
#[c]    ${omv}songPercentagePlayed=${d}(bc -l <<< ${q}${d}{${omv}songTimePlayed}/${d}{${omv}songLength}*100${q})
    ${omv}songLength=${q}${d}{${omv}songLength//./}${q}
    ${omv}songLength=${q}${d}{${omv}songLength:0:-3}${q}
    ${omv}songTimePlayed=${q}${d}{${omv}songTimePlayed//./}${q}
    ${omv}songTimePlayed=${q}${d}{${omv}songTimePlayed:0:-3}${q}
    ${omv}songPercentagePlayed=${d}((10#${d}{${omv}songTimePlayed}*100/10#${d}{${omv}songLength}))

    ${omv}songPercentagePlayed=${q}${d}{${omv}songPercentagePlayed%%.*}${q}
    [[ -z ${q}${d}{${omv}songPercentagePlayed}${q} ]] && ${omv}songPercentagePlayed=0
  
#[c]    echo -ne ${q}${d}{${ov}timeSliderErase}${q}
    ${o}.setcursorxy 0 0
    echo -n ${q}<${d}{${cmv}timeSlider:0:${d}((${omv}songPercentagePlayed*${omv}timeSliderLength/100))}${d}(printf '%02d%%' ${q}${d}{${omv}songPercentagePlayed#0}${q})${d}{${cmv}timeSlider:${d}((${omv}songPercentagePlayed*${omv}timeSliderLength/100)):${d}((${omv}timeSliderLength-(${omv}songPercentagePlayed*${omv}timeSliderLength/100) ))}>${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  buildSlider {
IFS='' read -r -d '' ${omv}method <<'EOF'
buildSlider {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    printf -v ${ov}timeSlider %${d}((${ov}width-2))s ${q}${q}
    ${ov}timeSliderErase=${q}${d}{${ov}timeSlider// /\\\\b}\\b\\b${q}
    ${ov}timeSliderFocused=${q}${d}{${ov}timeSlider// /\\~}${q}
    ${ov}timeSlider=${q}${d}{${ov}timeSlider// /-}${q}
    ${ov}timeSliderLength=${q}${d}{#${ov}timeSlider}${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function progressSlider.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setWidth
m=setWidth
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}width=${q}${d}1${q}
  ${o}.buildSlider
}"
#[cf]
  eval "
#[of]:    object data
newvar ${ov}timeSlider ${ov}timeSliderErase ${ov}timeSliderFocused ${ov}timeSliderLength

${ov}width=${q}${d}{1:-82}${q}
${ov}height=1
#[cf]
    ${o}.buildSlider
  "
}
#[cf]
#[cf]
#[of]:fileBrowser
#[of]:class meta
fileBrowser_cm_extends=screenObject
#[cf]
#[of]:static methods
function fileBrowser.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}index
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }

    [[ -z ${q}${d}{${ov}pwd}${q} ]] && ${o}.setPwd

    ${o}.runEventAction refresh

    for ((${omv}index=${ov}fileListIndexOffset;${omv}index<${ov}height+${ov}fileListIndexOffset;${omv}index++)) ; do
#[of]:      erase line
      ${o}.setcursorxy 0 ${d}((${omv}index-${ov}fileListIndexOffset))
      printf ${q}%${d}((${ov}width))s${q} ${q}${q}
#[cf]
#[of]:      print line
      if [[ -n ${q}${d}{${ov}indexLookupTable[${d}{${omv}index}]}${q} ]] ; then
        ${o}.setcursorxy 0 ${d}((${omv}index-${ov}fileListIndexOffset))
  
        ((${ov}selectedFile==${d}{${ov}indexLookupTable[${d}{${omv}index}]})) && ${o}.styleSetReverse
        echo -n ${q} ${d}{${ov}fileListTrimmed[${d}{${ov}indexLookupTable[${d}{${omv}index}]}]}${q}
        ((${ov}selectedFile==${d}{${ov}indexLookupTable[${d}{${omv}index}]})) && ${o}.styleSetNormal
      fi
#[cf]
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  updateFileList {
IFS='' read -r -d '' ${omv}method <<'EOF'
updateFileList {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}IFS ${omv}entry

    ${omv}IFS=${q}${d}{IFS}${q}
    IFS=${d}'\\n'
    ${ov}fileList=( ${d}( cd ${q}${d}{${ov}pwd}${q};{ find . -maxdepth 1 -type d | sort;find . -maxdepth 1 -type f | sort; } | grep -oP '^\\./\\K.*') )
    IFS=${q}${d}{${omv}IFS}${q}

    unset ${ov}fileListTrimmed
    for ${omv}entry in ${q}${d}{${ov}fileList[@]}${q} ; do
      screen.trimString ${omv}entry ${d}((${ov}width-2)) ${q}${d}{${omv}entry}${q}
      apush ${ov}fileListTrimmed ${q}${d}{${omv}entry}${q}
    done

    ((${d}{#${ov}fileList[@]}>0)) && eval ${q}${ov}indexLookupTable=( {0..${d}((${d}{#${ov}fileList[@]}-1))} )${q}
    ${ov}indexLookupTableReversed=( ${q}${d}{${ov}indexLookupTable[@]}${q} )

    ${ov}fileListIndexOffset=0
    ${ov}selectedFile=0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  selectFile {
IFS='' read -r -d '' ${omv}method <<'EOF'
selectFile {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}index

    if isnum ${q}${d}{1}${q} ; then
      if [[ -n ${q}${d}{${ov}indexLookupTable[${d}((${ov}fileListIndexOffset+${d}{1}))]}${q} ]] ; then
        ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}((${ov}fileListIndexOffset+${d}{1}))]}
      else
        return 1
      fi
    elif [[ -n ${q}${d}{1}${q} ]] ; then
      for ${omv}index in ${q}${d}{!${ov}fileList[@]}${q} ; do
        [[ ${q}${d}{${ov}fileList[${d}{${omv}index}]}${q} = ${q}${d}{1}${q} ]] && {
          ${ov}selectedFile=${d}{${omv}index}
          break
        }
      done
      for ((${ov}fileListIndexOffset=0;${ov}fileListIndexOffset<${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]-${ov}height;${ov}fileListIndexOffset+=${ov}height)) ; do :;done
    fi

    [[ ${q}${d}{${ov}fileList[${d}{${ov}selectedFile}]}${q} = ${q}..${q} ]] && {
      ${o}.refresh
      ${ov}pwd=${d}(cd ${q}${d}{${ov}pwd}${q};cd ..;pwd)
      ${o}.updateFileList
      return 1
    }
    [[ -d ${q}${d}{${ov}pwd}/${d}{${ov}fileList[${d}{${ov}selectedFile}]}${q} ]] && {
      ${o}.refresh
      ${ov}pwd=${d}(cd ${q}${d}{${ov}pwd}/${d}{${ov}fileList[${d}{${ov}selectedFile}]}${q};pwd)
      ${o}.updateFileList
      return 1
    }
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  incSelectedFile {
IFS='' read -r -d '' ${omv}method <<'EOF'
incSelectedFile {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}>=${d}{#${ov}fileList[@]}-1)) ; then
      ${ov}selectedFile=${d}{${ov}indexLookupTable[0]}
      ${ov}fileListIndexOffset=0
    else
      ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}+1))]}
    fi

    ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}-${ov}fileListIndexOffset>${ov}height-1)) && ${o}.pageDown
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  decSelectedFile {
IFS='' read -r -d '' ${omv}method <<'EOF'
decSelectedFile {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}==0)) ; then
      ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}((${d}{#${ov}fileList[@]}-1))]}
      for ((${ov}fileListIndexOffset=0;${ov}fileListIndexOffset<${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}-${ov}height-1;${ov}fileListIndexOffset=${ov}fileListIndexOffset+${ov}height)) do :; done
    else
      ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}-1))]}
    fi

    ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedFile}]}<${ov}fileListIndexOffset)) && {
      ${o}.pageUp
      ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}((${ov}fileListIndexOffset+${ov}height-1))]}
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  getSelectedFile {
IFS='' read -r -d '' ${omv}method <<'EOF'
getSelectedFile {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
      echo ${q}${d}{${ov}fileList[${d}{${ov}selectedFile}]}${q}
    else
      eval ${d}1=\\${q}\\${d}{${ov}fileList[\\${d}{${ov}selectedFile}]}\\${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setPwd {
IFS='' read -r -d '' ${omv}method <<'EOF'
setPwd {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}newPwd
    ${omv}newPwd=${q}${d}{1%/}${q}
  
    [[ -z ${q}${d}{${omv}newPwd}${q} ]] && ${omv}newPwd=${d}(pwd)
    
    [[ ${q}${d}{${ov}pwd}${q} != ${q}${d}{${omv}newPwd}${q} ]] && {
      if [[ -d ${q}${d}{${omv}newPwd}${q} ]] ; then
        ${ov}pwd=${q}${d}{${omv}newPwd}${q}
      else
        ${ov}pwd=${d}(pwd)
      fi
      ${o}.updateFileList
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function fileBrowser.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  fileListLookupShuffle
m=fileListLookupShuffle
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${d}{#${ov}fileList[@]}>0)) && ${ov}indexLookupTable=( ${d}(eval ${q}shuf -e {0..${d}((${d}{#${ov}fileList[@]}-1))}${q}) )

  unset ${ov}indexLookupTableReversed
  for _i in ${q}${d}{${ov}indexLookupTable[@]}${q};do ${ov}indexLookupTableReversed[${d}{_i}]=${d}{#${ov}indexLookupTableReversed[@]};done
  
  ${ov}fileListIndexOffset=0
  ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}{${ov}fileListIndexOffset}]}
}"
#[cf]
#[of]:  fileListLookupReset
m=fileListLookupReset
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${d}{#${ov}fileList[@]}>0)) && eval ${q}${ov}indexLookupTable=( {0..${d}((${d}{#${ov}fileList[@]}-1))} )${q}
  ${ov}indexLookupTableReversed=( ${q}${d}{${ov}indexLookupTable[@]}${q} )

  ${ov}fileListIndexOffset=0
  ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}{${ov}fileListIndexOffset}]}
}"
#[cf]
#[of]:  incFileListIndexOffset
m=incFileListIndexOffset
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}fileListIndexOffset<${d}{#${ov}fileList[@]}-${ov}height)) && ((${ov}fileListIndexOffset++))
}"
#[cf]
#[of]:  decFileListIndexOffset
m=decFileListIndexOffset
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}fileListIndexOffset>0)) && ((${ov}fileListIndexOffset--))
}"
#[cf]
#[of]:  pageUp
m=pageUp
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}fileListIndexOffset>0)) && ((${ov}fileListIndexOffset=${ov}fileListIndexOffset-${ov}height))
  ((${ov}fileListIndexOffset<0)) && ${ov}fileListIndexOffset=0
  ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}{${ov}fileListIndexOffset}]}
}"
#[cf]
#[of]:  pageDown
m=pageDown
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}fileListIndexOffset<${d}{#${ov}fileList[@]}-${ov}height)) && ((${ov}fileListIndexOffset=${ov}fileListIndexOffset+${ov}height))
  ${ov}selectedFile=${d}{${ov}indexLookupTable[${d}{${ov}fileListIndexOffset}]}
}"
#[cf]
#[of]:  public settable object data
  newPublicVar pwd
#[cf]
  eval "
#[of]:    object data
newvar ${ov}fileList ${ov}fileListTrimmed ${ov}fileListIndexOffset ${ov}indexLookupTable
newvar ${ov}selectedFile

(($#>2)) && ${o}.setPwd ${q}${d}{3:-${d}(pwd)}${q}
#[cf]
#[c]    ${o}.updateFileList
  "
}
#[cf]
#[cf]
