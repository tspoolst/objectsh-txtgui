#!/bin/bash
#[of]:comments
#[of]:mouse movements
#[c]mouse drag and drop
#[c]on mouse down record object and position of down event
#[c]  on mouseDrag
#[c]    generate drag mp(message package) i.e. filename/url/etc.
#[c]    on mouse up send mp to object that received the mouseUp event via a mouseDrop 
#[c]  remove mouse down event data
#[cf]
#[c]
#[of]:separate refresh events
#[c]add individual control screen updates
#[c]  already exist if $(o).refresh is called on a control object
#[c]    however most controls don't have code to erase that block of screen first
#[c]  if refresh called on a screen/window all children of that screen/window are updated
#[cf]
#[c]
#[c]
#[c]implement layer selection
#[c]  all objects default to layer 0 (the lowest layer)
#[c]  
#[c]
#[c]build
#[c]  listbox
#[c]    can contain check-boxes(1 or more selections) or circle-selectors(only 1 selection)
#[c]  dropdown
#[c]    like any other type of object, but it must always be draw above all other object
#[c]  textbox
#[c]    a textbox implies the ability to edit text
#[c]
#[c]modify
#[c]  label - perhaps rename all button references to label
#[c]    a button is just a label (usually with a border drawn) with key/mouse events tagged to it.
#[c]
#[c]
#[of]:notes
#[c]If you are displaying text, that is, there is no user input...use a label.
#[c]If you are trying to get user input, use a textbox.
#[c]
#[cf]
#[cf]
#[c]
#[c]
#[of]:screenCore
#[of]:description
#[c]screen object base object
#[cf]
#[of]:class meta
screenCore_cm_baseClass=
#[cf]
#[of]:class methods
function screenCore.classconstructor {
#[c]object
#[of]:  includes
  include hash
  include referenceid
#[cf]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    class data

#[cf]
  "
}
#[cf]
#[of]:static methods
function screenCore.staticconstructor {
  typeset ${omv}method
#[of]:  bindEventAction
IFS='' read -r -d '' ${omv}method <<'EOF'
bindEventAction {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset _i
    for _i in ${q}${d}{@:1:${d}#-1}${q} ; do
      ${ov}inputEventActions.setkey ${q}${d}{_i}${q} ${q}${d}{@: -1}${q}
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  drawBorder {
IFS='' read -r -d '' ${omv}method <<'EOF'
drawBorder {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}line  ${omv}h ${omv}v  ${omv}tl_br ${omv}tr_bl ${omv}index
    case ${q}${d}{${ov}borderStyle}${q} in
      1)
        ${omv}h='-'
        ${omv}v='|'
        ${omv}tl_br='/'
        ${omv}tr_bl='\'
        ;;
      *)
        ${omv}h='*'
        ${omv}v='*'
        ${omv}tl_br='*'
        ${omv}tr_bl='*'
        ;;
    esac

#[of]:    draw top border
    ((${ov}width>2)) && {
      ${o}.setcursorxy 0 0
      printf -v ${omv}line ${q}%${d}((${ov}width-2))s${q} ${q}${q};echo -n ${q}${d}{${omv}tl_br}${d}{${omv}line// /${d}{${omv}h}}${d}{${omv}tr_bl}${q}
    }
#[cf]
    ((${ov}height>2)) && {
#[of]:      draw left border
      ${o}.setcursorxy 0 1
      printf -v ${omv}line ${q}%${d}((${ov}height-3))s${q} ${q}${q};{ echo -n ${q}${d}{${omv}v}${q};echo -en ${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}; }
#[cf]
#[of]:      draw right border
#[c]      ${o}.setcursorxy ${d}((${ov}width-1)) 1
#[c]      printf -v ${omv}line ${q}%${d}((${ov}height-3))s${q} ${q}${q};{ echo -n ${q}${d}{${omv}v}${q};echo -en ${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}; }
  
      for ((${omv}index=1;${omv}index<${ov}height-1;${omv}index++)) ; do
        ${o}.setcursorxy $((${ov}width-1)) ${d}{${omv}index}
        echo -n ${q}${d}{${omv}v}${q}
      done
#[cf]
    }
#[of]:    draw bottom border
    ((${ov}width>2)) && {
      ${o}.setcursorxy 0 ${d}((${ov}height-1))
      printf -v ${omv}line ${q}%${d}((${ov}width-2))s${q} ${q}${q};echo -n ${q}${d}{${omv}tr_bl}${d}{${omv}line// /${d}{${omv}h}}${d}{${omv}tl_br}${q}
    }
#[cf]

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenCore.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  addParent
m=addParent
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  apush ${ov}screenParents ${q}${d}1${q}
}"
#[cf]
#[of]:  delParent
m=delParent
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset ${omv}index
  for ${omv}index in ${q}${d}{!${ov}screenParents[@]}${q} ; do
    if [[ ${q}${d}{${ov}screenParents[${d}{${omv}index}]}${q} = ${q}${d}1${q} ]] ; then
      unset ${ov}screenParents[${d}{${omv}index}]
      ${ov}screenParents=( ${q}${d}{${ov}screenParents[@]}${q} )
      break
    fi
  done
}"
#[cf]
#[of]:  getParent
m=getParent
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
    echo ${q}${d}{${ov}screenParents[0]}${q}
  else
    eval ${d}1=\\${q}\\${d}{${ov}screenParents[0]}\\${q}
  fi
}"
#[cf]
#[of]:  delEventAction
m=delEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}inputEventActions.delkey ${q}${d}1${q}
}"
#[cf]
#[of]:  getEventAction
m=getEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
  ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}5${q}
}"
#[cf]
#[of]:  runEventAction {
m=runEventAction
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset ${omv}objectName ${omv}action o
  o=${o}
  if ${o}.getEventAction ${omv}objectName ${omv}action ! ! ${q}${d}1${q} ; then
    trap ${q}echo TRAPed signal${q} INT
    eval ${q}${d}{${omv}action}${q}
    trap - INT
  else
    return 1
  fi
}"
#[cf]
#[of]:  setcursorxy
m=setcursorxy
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset ${omv}x ${omv}y
  ${omv}x=${d}1
  ${omv}y=${d}2
  echo -en ${q}\\\\033[${d}((${ov}topOffset+1+${omv}y));${d}((${ov}leftOffset+1+${omv}x))H${q}
  return 0
}"
#[cf]
#[of]:  styleSetNormal
m=styleSetNormal
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  echo -en ${q}\\033[0m${q}
}"
#[cf]
#[of]:  styleSetReverse
m=styleSetReverse
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  echo -en ${q}\\033[7m${q}
}"
#[cf]
#[of]:  public settable object data
  newPublicVar height width title drawBorder borderStyle
#[cf]
  eval "
#[of]:    object data
newvar ${ov}leftOffset ${ov}topOffset
newvar ${ov}screenParents
new hash ${ov}inputEventActions

${ov}leftOffset=0
${ov}topOffset=0

${ov}drawBorder=0
${ov}borderStyle=0

${ov}width=${q}${d}{1:-0}${q}
${ov}height=${q}${d}{2:-1}${q}
#[cf]
  "
}
#[cf]
#[cf]
#[c]
#[of]:screenManage
#[of]:description
#[c]screen object base object
#[cf]
#[of]:class meta
screenManage_cm_baseClass=screenCore
#[cf]
#[of]:static methods
function screenManage.staticconstructor {
  typeset ${omv}method
#[of]:  bindObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
bindObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}left ${omv}top ${omv}width ${omv}height
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}
    ${omv}left=${q}${d}2${q}
    ${omv}top=${q}${d}3${q}
    ${d}{${omv}objectName}.getHeight ${omv}height
    ${d}{${omv}objectName}.getWidth ${omv}width

#[of]:    prevent object from being added twice to the same screen/window
    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        return 0
        break
      fi
    done
#[cf]

    ${d}{${omv}objectName}.addParent ${o}

    ${ov}objectIdPool.getid ${omv}objectId

    ${ov}objectNames[${d}{${omv}objectId}]=${q}${d}{${omv}objectName}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+0))]=${q}${d}{${omv}left}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+1))]=${q}${d}((${omv}left + ${omv}width-1))${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+2))]=${q}${d}{${omv}top}${q}
    ${ov}objectPositions[${d}((4*${omv}objectId+3))]=${q}${d}((${omv}top + ${omv}height-1))${q}
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[c]
#[c]
#[c]
#[cf]
#[of]:  resizeObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
resizeObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}left ${omv}top ${omv}width ${omv}height
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}
    ${d}{${omv}objectName}.getHeight ${omv}height
    ${d}{${omv}objectName}.getWidth ${omv}width

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        ${omv}left=${q}${d}{${ov}objectPositions[${d}((4*${omv}objectId+0))]}${q}
        ${omv}top=${q}${d}{${ov}objectPositions[${d}((4*${omv}objectId+2))]}${q}
        ${ov}objectPositions[${d}((4*${omv}objectId+1))]=${q}${d}((${omv}left + ${omv}width -1))${q}
        ${ov}objectPositions[${d}((4*${omv}objectId+3))]=${q}${d}((${omv}top + ${omv}height -1))${q}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  delObject {
IFS='' read -r -d '' ${omv}method <<'EOF'
delObject {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId
    typeset ${omv}objectName

    ${omv}objectName=${q}${d}1${q}

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        unset ${ov}objectNames[${d}{${omv}objectId}]
        ${ov}objectIdPool.delid ${d}{${omv}objectId}
        ${d}{${omv}objectName}.delParent ${o}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[c]
#[of]:  focusAdd {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusAdd {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}objectName ${omv}objectLocated ${omv}focusListKey 
    ${omv}objectLocated=0
    ${omv}objectName=${q}${d}1${q}

    #check if object is already in the focus list    
    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q} ]] ; then
        return 0
      fi
    done

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} ]] ; then
        ${omv}objectLocated=1
        break
      fi
    done
    if ((${omv}objectLocated)) ; then
      apush ${ov}focusList ${q}${d}{${omv}objectId}${q}
    else
      die 1 ${q}${c}.${d}{FUNCNAME[1]##*.} -- the control object ${d}{${omv}objectName} is not bound to ${o}${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusDel {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusDel {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return
    typeset ${omv}focusListKey ${omv}objectName ${omv}objectLocated
    ${omv}objectName=${q}${d}1${q}
    
    for ${omv}focusListKey in ${q}${d}{!${ov}focusList[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]##*_}${q} ]] ; then
        unset ${ov}focusList[${d}{${omv}focusListKey}]
        ${ov}focusList=( ${q}${d}{${ov}focusList[@]}${q} )
        break
      fi
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenManage.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    object data
#[cf]
  "
}
#[cf]
#[cf]
#[of]:screen
#[of]:description
#[c]screen
#[c]  size: grab from terminal
#[c]  handle all Key/Mouse Events
#[c]    button events happen either on the screen or in a window
#[c]  window
#[c]    button
#[c]    slider
#[c]    filebrowser
#[cf]
#[of]:class meta
screen_cm_baseClass=screenManage
#[cf]
#[of]:class methods
function screen.classconstructor {
#[c]object
#[of]:  includes

#[cf]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    function ${c}.mouseEnable {
function ${c}.mouseEnable {
  stty -echo
  if [[ ${q}${d}1${q} == ${q}-d${q} ]] ; then
    echo -en '\e[?1002;1006;1015h'
  else
    echo -en '\e[?1000;1006;1015h'
  fi
}
#[cf]
#[of]:    function ${c}.mouseDisable {
function ${c}.mouseDisable {
  stty echo
  echo -en '\e[?1000;1001;1002;1003;1006;1015l'
}
#[cf]
#[of]:    function ${c}.stringLength {
function ${c}.stringLength {
## prints only the length of the longest line in a file
  if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
    echo ${d}(wc -L <<< ${q}${d}2${q})
  else
    eval ${q}${d}1=\\${d}(wc -L <<< \\${q}\\${d}2\\${q})${q}
  fi
}
#[cf]
#[of]:    function ${c}.trimString {
function ${c}.trimString {
  typeset _s
  _s=${q}${d}3${q}
  while ((${d}(wc -L <<< ${q}${d}{_s}${q})>${d}{2}));do _s=${q}${d}{_s%?}${q};done
  if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
    echo ${q}${d}{_s}${q}
  else
    eval ${d}1=\\${q}\\${d}{_s}\\${q}
  fi

}
#[cf]
#[of]:    class data

#[cf]
    ${o}.calcScreenSize
  "
}
#[cf]
#[of]:static methods
function screen.staticconstructor {
  typeset ${omv}method
#[of]:  open {
IFS='' read -r -d '' ${omv}method <<'EOF'
open {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}key ${omv}mouse
    typeset ${omv}mouseEvent ${omv}mouseEvents ${omv}mouseButtonId ${omv}mouseButtonName
    typeset ${omv}mouseXStart ${omv}mouseYStart ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentRelX ${omv}currentRelY ${omv}relX ${omv}relY
    typeset ${omv}mouseButtonState ${omv}shift ${omv}alt ${omv}ctrl
    typeset ${omv}objectNamesKeys
    typeset ${omv}objectName ${omv}objectId
    typeset ${omv}triggerId

    ${omv}refreshInterval=${q}${d}{${ov}refreshInterval}${q}

    ${o}.calcScreenSize
    ${o}.focusListBuild
    ${o}.focusTriggerFocusEvent enter
    clear
    ${o}.refresh
    ${c}.mouseEnable -d
#[of]:    key process loop
    while : ; do
      ((${ov}flagExit)) && {
        ${ov}flagExit=0
        break
      }
      read -s -N 1 -r ${d}{${ov}tickIntervalSeconds:+-t ${d}{${ov}tickIntervalSeconds}} ${omv}key || {
        ((${ov}tick+=1))
        ((${ov}tick>${ov}tickMax)) && ${ov}tick=0

        for ${omv}triggerId in ${q}${d}{!${ov}timerTriggerIdList[@]}${q} ; do
          ((${ov}tick%${ov}tickTriggers[${d}((${omv}triggerId*3))]==0)) && {
            ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+1))]}.runEventAction ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+2))]}
          }
        done

        ((${ov}refreshInterval>0)) && ((${ov}tick%${ov}refreshInterval==0)) && ${o}.refresh
        continue
      }
      case ${q}${d}{${omv}key}${q} in
#[of]:        escaped keys
        ${d}'\e')
          read -s -N 2 -r -t .1 ${omv}key || {
#[of]:            esc
#[c]            esc itself is just a single char
#[c]            if read timeout is reached the key must be esc
            ${omv}key=esc
            ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
            ${o}.processEvent \
              ${q}${d}{${omv}objectName}${q} \
              ${q}${d}{${omv}key}${q} \
              0 0 \
              0 0 || \
            echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
            continue
#[cf]
          }
          [[ ${q}${d}{${omv}key}${q} == '[1' ]] && read -s -N 3 -r -t .1 ${omv}key
          case ${q}${d}{${omv}key}${q} in
#[of]:            mouse
            '[<')
#[of]:              read mouse input strings from terminal
              ${omv}mouseButtonId=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseButtonId=${q}${d}{${omv}mouseButtonId}${d}{${omv}key}${q}
              done
              ${omv}mouseX=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseX=${q}${d}{${omv}mouseX}${d}{${omv}key}${q}
              done
              ${omv}mouseY=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [ -z ${q}${d}{${omv}key#[Mm]}${q} ] && break
                ${omv}mouseY=${q}${d}{${omv}mouseY}${d}{${omv}key}${q}
              done
              [[ ${q}${d}{${omv}key}${q} == ${q}M${q} ]] && ${omv}mouseButtonState=${q}Down${q} || ${omv}mouseButtonState=${q}Up${q}
              ((${omv}mouseX--))
              ((${omv}mouseY--))
#[cf]
#[of]:              decode mouse input into event tags

#[c]              left middle right scroll_Up scroll_Down
#[c]              shift alt ctrl

              (( (${omv}mouseButtonId & 4 )==4  )) && ${omv}shift=${q}Shift${q} || ${omv}shift=${q}${q}
              (( (${omv}mouseButtonId & 8 )==8  )) && ${omv}alt=${q}Alt${q}     || ${omv}alt=${q}${q}
              (( (${omv}mouseButtonId & 16)==16 )) && ${omv}ctrl=${q}Ctrl${q}   || ${omv}ctrl=${q}${q}
              (( (${omv}mouseButtonId & 32)==32 )) && ${omv}mouseButtonState=${q}Drag${q}
              case ${q}${d}((${omv}mouseButtonId & 67))${q} in
                 0) ${omv}mouseButtonName=${q}Left${q}   ;;&
                 1) ${omv}mouseButtonName=${q}Middle${q} ;;&
                 2) ${omv}mouseButtonName=${q}Right${q}  ;;&
                64) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Up${q}    ;;
                65) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Down${q}  ;;
                 *) case ${q}${d}{${omv}mouseButtonState}${q} in
                      Down)
                        ${ov}previousMouseButtonName=${q}${d}{${omv}mouseButtonName}${q}
                        ${ov}previousMouseX=${q}${d}{${omv}mouseX}${q}
                        ${ov}previousMouseY=${q}${d}{${omv}mouseY}${q}
                        ;;
                      Up)
                        [[  ${q}${d}{${ov}previousMouseButtonName}${q} = ${q}${d}{${omv}mouseButtonName}${q} &&
                            ${q}${d}{${ov}previousMouseX}${q} = ${q}${d}{${omv}mouseX}${q} &&
                            ${q}${d}{${ov}previousMouseY}${q} = ${q}${d}{${omv}mouseY}${q} ]] && \
                          aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}Click${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}
                        ;;
                    esac
                    ;;
              esac
              aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}${d}{${omv}mouseButtonState}${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}
#[cf]

#[c]              object on screen has TOPxLEFT and WIDTHxHEIGHT
#[c]                button Down event
#[c]                  -if xy no longer on the current object it is a drag-drop operation
#[c]                  setCurrentScreenObject buttonID/textBoxID/windowID/etc...
#[c]                  screen.objectID.sendEvent mouse_Left_Down x-left y-top
#[c]                button Up event
#[c]                  screen.objectID.sendEvent mouse_Left_Up objectID sx-left sy-top x-left y-top
#[c]                
#[c]              
#[c]              for objectID in screen_objects do
#[c]                if top<y<top+height && left<x<left+width ; then
#[c]                  if [[ ${q}${d}{${omv}mouseButtonName}${q} == ${q}scroll${q} || ${q}${d}{${omv}mouseButtonState}${q} == ${q}Down${q} ]] && setCurrentScreenObject=${objectID}
#[c]                  screen.sendEvent objectID mouse_Left_Down x-left y-top
#[c]                  break
#[c]                fi
#[c]              done

#[of]:              find object under current mouse position
              ${omv}relX=${d}{${omv}mouseX}
              ${omv}relY=${d}{${omv}mouseY}
              ${omv}objectName=${q}${q}

              ## this gets the keys from ${ov}objectNames and then loops through them in reverse
              ${omv}objectNamesKeys=( ${d}{!${ov}objectNames[@]} )
              for ((i=${d}{#${omv}objectNamesKeys[@]}-1;i>=0;i--));do
                ${omv}objectId=${q}${d}{${omv}objectNamesKeys[${d}{i}]}${q}
                if  (( ${ov}objectPositions[4*${omv}objectId+0] <= ${omv}mouseX &&
                    ${omv}mouseX <= ${ov}objectPositions[${d}((4*${omv}objectId+1))] &&
                   ${ov}objectPositions[4*${omv}objectId+2] <= ${omv}mouseY &&
                   ${omv}mouseY <= ${ov}objectPositions[4*${omv}objectId+3] ))
                then
                  ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q}
#[of]:                  calculate relative position for found object
                  ${omv}relX=${d}(( ${omv}mouseX - ${ov}objectPositions[4*${omv}objectId+0] ))
                  ${omv}relY=${d}(( ${omv}mouseY - ${ov}objectPositions[4*${omv}objectId+2] ))
#[cf]
                  break
                fi
              done
#[cf]

#[c]###write some code that disables event actions and just shows mouse events
#[c]###be sure the code shows screen object calls as well
              ((gl_debug>0)) && echo ${q}s - ${d}{!${ov}objectPositions[@]} | ${d}{${ov}objectPositions[@]} -- ${d}{${omv}objectName:-${o}} ${d}{${omv}mouseEvent} ${d}{${omv}relX} ${d}{${omv}relY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}${q}

#[of]:              process mouse event queue list
              while ashift ${omv}mouseEvent ${omv}mouseEvents ; do
                ${o}.processEvent \
                  ${q}${d}{${omv}objectName:-${o}}${q} \
                  ${q}${d}{${omv}mouseEvent}${q} \
                  ${q}${d}{${omv}relX}${q} ${q}${d}{${omv}relY}${q} \
                  ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
              done
#[cf]
              ;;
#[cf]
#[of]:            shift up)
            '[a'|';2A')
              ${omv}key=shiftUp
              ;;&
#[cf]
#[of]:            shift down)
            '[b'|';2B')
              ${omv}key=shiftDown
              ;;&
#[cf]
#[of]:            shift left)
            '[d'|';2D')
              ${omv}key=shiftLeft
              ;;&
#[cf]
#[of]:            shift right)
            '[c'|';2C')
              ${omv}key=shiftRight
              ;;&
#[cf]
#[of]:            alt up)
            ';3A')
              ${omv}key=altUp
              ;;&
#[cf]
#[of]:            alt down)
            ';3B')
              ${omv}key=altDown
              ;;&
#[cf]
#[of]:            alt left)
            ';3D')
              ${omv}key=altLeft
              ;;&
#[cf]
#[of]:            alt right)
            ';3C')
              ${omv}key=altRight
              ;;&
#[cf]
#[of]:            ctrl up)
            ';5A')
              ${omv}key=ctrlUp
              ;;&
#[cf]
#[of]:            ctrl down)
            ';5B')
              ${omv}key=ctrlDown
              ;;&
#[cf]
#[of]:            ctrl left)
            ';5D')
              ${omv}key=ctrlLeft
              ;;&
#[cf]
#[of]:            ctrl right)
            ';5C')
              ${omv}key=ctrlRight
              ;;&
#[cf]
#[of]:            up)
            '[A')
              ${omv}key=up
              ;;&
#[cf]
#[of]:            down)
            '[B')
              ${omv}key=down
              ;;&
#[cf]
#[of]:            left)
            '[D')
              ${omv}key=left
              ;;&
#[cf]
#[of]:            right)
            '[C')
              ${omv}key=right
              ;;&
#[cf]
#[of]:            shift tab)
            '[Z')
              ${omv}key=shiftTab
              ;;&
#[cf]
#[of]:            page up)
            '[5')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageUp
              ;;&
#[cf]
#[of]:            page down)
            '[6')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageDown
              ;;&
#[cf]
#[of]:            *)
            *)
              ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
              ${o}.processEvent \
                ${q}${d}{${omv}objectName}${q} \
                ${q}${d}{${omv}key}${q} \
                0 0 \
                0 0 || \
              echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
              ;;
#[cf]
          esac
          ;;
#[cf]
#[of]:        enter)
        '
')
          ${omv}key=enter
          ;;&
#[cf]
#[of]:        tab)
        '	')
          ${omv}key=tab
          ;;&
#[cf]
#[of]:        tick)
        '')
          ;;
#[cf]
#[of]:        *)
        *)
          [[ -n ${q}${d}{${omv}key##*[^[:cntrl:]]*}${q} ]] && {
            [[ ${d}(printf %d ${d}(printf %s ${q}${d}{${omv}key}${q} | od -An -t dC)) = 127 ]] && \
              ${omv}key=backspace
          }

          ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
          ${o}.processEvent \
            ${q}${d}{${omv}objectName}${q} \
            ${q}${d}{${omv}key}${q} \
            0 0 \
            0 0 || \
          echo ${q}ascii ---${d}{${omv}key}---chr---${d}{${omv}objectName:-${o}}${q}
          ;;
#[cf]
      esac
    done
#[cf]
    ${c}.mouseDisable
    clear
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((gl_debug>0)) && return
    typeset ${omv}objectId ${omv}left ${omv}top
    
#[c]    clear

    ${o}.runEventAction refresh

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
    ${omv}left=${d}{${ov}objectPositions[4*${omv}objectId+0]}
    ${omv}top=${d}{${ov}objectPositions[4*${omv}objectId+2]}
      ${o}.setcursorxy ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.refresh \
        ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q} \
        ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} \
        ${q}${d}{${ov}focusListMerged[${ov}focusedObjectIndex]}${q}
    done
    ${o}.setcursorxy 0 0

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  timerTriggerAdd {
IFS='' read -r -d '' ${omv}method <<'EOF'
timerTriggerAdd {
#[c]object objectname event_to_trigger tick_devisor
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}triggerId

    ${ov}timerTriggerIdPool.getid ${omv}triggerId
    ${ov}timerTriggerIdList[${d}{${omv}triggerId}]=''

    ${ov}tickTriggers[${d}((${omv}triggerId*3))]=${q}${d}3${q}
    ${ov}tickTriggers[${d}((${omv}triggerId*3+1))]=${q}${d}1${q}
    ${ov}tickTriggers[${d}((${omv}triggerId*3+2))]=${q}${d}2${q}
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  timerTriggerDel {
IFS='' read -r -d '' ${omv}method <<'EOF'
timerTriggerDel {
#[c]object objectname event_to_trigger
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}triggerName ${omv}triggerId

    ${omv}triggerName=${q}${d}1_${d}2${q}

    for ${omv}triggerId in ${q}${d}{!${ov}timerTriggerIdList[@]}${q} ; do
      if [[ ${q}${d}{${omv}triggerName}${q} = ${q}${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+1))]}_${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+2))]}${q} ]] ; then
        unset ${ov}timerTriggerIdList[${d}{${omv}triggerId}]
        ${ov}timerTriggerIdPool.delid ${d}{${omv}triggerId}
        break
      fi
    done

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  processEvent {
IFS='' read -r -d '' ${omv}method <<'EOF'
processEvent {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectName ${omv}event
    typeset ${omv}relX ${omv}relY ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentObjectName ${omv}currentRelX ${omv}currentRelY
  
    ${omv}objectName=${q}${d}1${q}
    ${omv}event=${q}${d}2${q}
    ${omv}relX=${q}${d}3${q}
    ${omv}relY=${q}${d}4${q}
    ${omv}mouseX=${q}${d}5${q}
    ${omv}mouseY=${q}${d}6${q}

    ${omv}currentRelX=${q}${d}{${omv}relX}${q}
    ${omv}currentRelY=${q}${d}{${omv}relY}${q}
    ${d}{${omv}objectName:-${o}}.getEventAction \
      ${omv}currentObjectName ! \
      ${omv}currentRelX ${omv}currentRelY \
      ${q}${d}{${omv}event}${q} \
      ${q}${d}{${omv}relX}${q} ${q}${d}{${omv}relY}${q} \
      ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q} && {
          if ! ((gl_debug>1)) ; then
            ${c}.mouseDisable
            ((gl_debug>0)) && echo ${d}{${omv}currentObjectName}.runEventAction \
              ${q}${d}{${omv}event}${q} \
              ${q}${d}{${omv}currentRelX}${q} ${q}${d}{${omv}currentRelY}${q} \
              ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
            ${d}{${omv}currentObjectName}.runEventAction \
              ${q}${d}{${omv}event}${q} \
              ${q}${d}{${omv}currentRelX}${q} ${q}${d}{${omv}currentRelY}${q} \
              ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
            #${o}.calcScreenSize
            ${o}.refresh
            ${c}.mouseEnable -d
          else
            echo ${d}{${omv}currentObjectName}.runEventAction ${q}${d}{${omv}event}${q} ${d}{${omv}currentRelX} ${d}{${omv}currentRelY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}
          fi
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  focusListBuild {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusListBuild {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}objectName ${omv}focusListKey ${omv}focusList
    unset ${ov}focusListMerged

    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q}
      if isfnset ${d}{${omv}objectName}.focusList ; then
        ${d}{${omv}objectName}.focusList ${omv}focusList ${q}${d}{${omv}objectName}${q}
        apush ${ov}focusListMerged ${q}${d}{${omv}focusList[@]}${q}
      else
        apush ${ov}focusListMerged ${q}${d}{${omv}objectName}${q}
      fi
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusSelectByName {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusSelectByName {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew
    typeset ${omv}focusListKey ${omv}objectName ${omv}objectLocated
    ${omv}objectLocated=0
    ${omv}objectName=${q}${d}1${q}

    ${o}.focusListBuild
    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    for ${omv}focusListKey in ${q}${d}{!${ov}focusListMerged[@]}${q} ; do
      if [[ ${q}${d}{${omv}objectName}${q} = ${q}${d}{${ov}focusListMerged[${d}{${omv}focusListKey}]##*_}${q} ]] ; then
        ${omv}objectLocated=1
        ${ov}focusedObjectIndex=${d}{${omv}focusListKey}
        break
      fi
    done
    if ! ((${omv}objectLocated)) ; then
      die 1 ${q}${c}.${d}{FUNCNAME[1]##*.} -- the control object ${d}{${omv}objectName} is not in the ${o} focusList${q}
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    
    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusTriggerFocusEvent {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusTriggerFocusEvent {
#[c]
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 0

    typeset ${omv}objectName ${omv}event
    ${omv}event=${d}{1^}
    ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    ${o}.processEvent ${q}${d}{${omv}objectName}${q} ${q}focus${d}{${omv}event}${q} 0 0 0 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  focusNext {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusNext {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 1

    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew ${omv}objectName

    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if ((${ov}focusedObjectIndex>=${d}{#${ov}focusListMerged[@]}-1)) ; then
      ${ov}focusedObjectIndex=0
    else
      ((${ov}focusedObjectIndex++))
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
    
    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[c]
#[c]focus needs to be by tree connection not by object name
#[c]screen + window need to tell the object it has focus on render
#[c]
#[c]crawl the tree and gather object IDs
#[c]how to represent this? rest-ish
#[c]
#[c]
#[c]
#[c]if currenly focused object is a window
#[c]  call w.finc || f.inc
#[c]
#[c]
#[c]s1 ---\------1-fb--1-fb
#[c]       \ 
#[c]        \----2-pl--\--1-cl--\-----1-b1
#[c]         \          \-2-bf   \----2-b2
#[c]          \                   \---3-b3
#[c]           \-3-lb--1-b1        \--4-b4
#[c]                                \-5-sl
#[c]
#[c]1-1
#[c]2-1-1
#[c]2-1-2
#[c]2-1-3
#[c]2-1-4
#[c]2-1-5
#[c]2-2
#[c]3-1
#[c]
#[c]
#[c]
#[c]s1.focusAdd mediaPlayerBox
#[c]  mediaPlayerBox.focusAdd playerControls
#[c]    playerControls.focusAdd mediaPlayerButton1
#[c]  mediaPlayerBox.focusAdd bf
#[c]
#[c]a 0
#[c]b 0
#[c]a 1
#[c]b 0
#[c]a 1
#[cf]
#[of]:  focusPrevious {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusPrevious {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ((${d}{#${ov}focusList[@]})) || return 1

    typeset ${omv}focusedObjectCurrent ${omv}focusedObjectNew ${omv}objectName

    ${omv}focusedObjectCurrent=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if ((${ov}focusedObjectIndex==0)) ; then
      ((${ov}focusedObjectIndex=${d}{#${ov}focusListMerged[@]}-1))
    else
      ((${ov}focusedObjectIndex--))
    fi

    ${omv}focusedObjectNew=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}

    if [[ ${q}${d}{${omv}focusedObjectCurrent}${q} != ${q}${d}{${omv}focusedObjectNew}${q} ]] ; then
      ${o}.processEvent ${q}${d}{${omv}focusedObjectCurrent}${q} ${q}focusExit${q} 0 0 0 0
      ${o}.processEvent ${q}${d}{${omv}focusedObjectNew}${q} ${q}focusEnter${q} 0 0 0 0
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]

#[of]:  calcscreensize {
IFS='' read -r -d '' ${omv}method <<'EOF'
calcScreenSize {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    set -- ${d}(stty size 2>/dev/null)
    ${ov}height=${d}1
    ${ov}width=${d}2
    [[ -z ${q}${d}{${ov}height}${q} ]] && {
      ${ov}height=24
      ${ov}width=80
    }
#[c]    echo ${d}{${ov}height} ${d}{${ov}width}
#[c]    read -n 1
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setScreenHeight {
IFS='' read -r -d '' ${omv}method <<'EOF'
setScreenHeight {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    #to get the resize command
    #sudo apt install xterm
    typeset ${omv}height
    
    if isset TERM && [[ -z ${q}${d}{TERM##xterm*}${q} ]] && which resize &>/dev/null ; then
      ${omv}height=${d}1
      resize -s ${d}{${omv}height} ${d}{${ov}width} &>/dev/null || return 1
      ${ov}height=${d}{${omv}height}
    else
      return 1
    fi
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setScreenWidth {
IFS='' read -r -d '' ${omv}method <<'EOF'
setScreenWidth {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    #to get the resize command
    #sudo apt install xterm
    typeset ${omv}width
  
    if isset TERM && [[ -z ${q}${d}{TERM##xterm*}${q} ]] && which resize &>/dev/null ; then
      ${omv}width=${d}1
      resize -s ${d}{${ov}height} ${d}{${omv}width} &>/dev/null || return 1
      ${ov}width=${d}{${omv}width}
    else
      return 1
    fi
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screen.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setRefreshInterval
m=setRefreshInterval
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  if [[ -z ${q}${d}1${q} ]] ; then
    ${ov}refreshInterval=${q}0${q}
  else
    ${ov}refreshInterval=${q}${d}1${q}
  fi
}"
#[cf]
#[of]:  setTickInterval
m=setTickInterval
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  typeset _precision
  if [[ -z ${q}${d}1${q} || ${q}${d}1${q} = 0 ]] ; then
    ${ov}tickIntervalSeconds=${q}${q}
  else
    _precision=100
    ${ov}tick=0
    ${ov}tickInterval=${q}${d}1${q}
    ${ov}tickMax=${d}((_precision*1000/${ov}tickInterval*${ov}cycleLength/_precision))
    printf -v ${ov}tickIntervalSeconds '%04d' ${q}${d}{${ov}tickInterval}${q}
    ${ov}tickIntervalSeconds=${q}${d}{${ov}tickIntervalSeconds%???}.${d}{${ov}tickIntervalSeconds#${d}{${ov}tickIntervalSeconds%???}}${q}
  fi
}"
#[cf]
#[of]:  exit
m=exit
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}flagExit=1
}"
#[cf]
  eval "
#[of]:    object data
newvar ${ov}objectPositions ${ov}objectNames
newvar ${ov}previousMouseButtonName ${ov}previousMouseX ${ov}previousMouseY

new hash ${ov}objects

new referenceid ${ov}objectIdPool

newvar ${ov}flagExit
${ov}flagExit=0

newvar ${ov}focusedObjectIndex ${ov}focusedObjectName ${ov}focusList ${ov}focusListMerged
${ov}focusedObjectIndex=0


typeset _precision
newvar ${ov}tick ${ov}tickInterval ${ov}cycleLength ${ov}tickMax ${ov}tickIntervalSeconds
newvar ${ov}timerTriggerIdList ${ov}tickTriggers
new referenceid ${ov}timerTriggerIdPool
_precision=100
${ov}tick=0
${ov}tickInterval=1000
${ov}cycleLength=${d}((24*60*60))

${ov}tickMax=${d}((_precision*1000/${ov}tickInterval*${ov}cycleLength/_precision))
printf -v ${ov}tickIntervalSeconds '%04d' ${q}${d}{${ov}tickInterval}${q}
${ov}tickIntervalSeconds=${q}${d}{${ov}tickIntervalSeconds%???}.${d}{${ov}tickIntervalSeconds#${d}{${ov}tickIntervalSeconds%???}}${q}

newvar ${ov}refreshInterval
${ov}refreshInterval=10

#[cf]
  "
}
#[cf]
#[cf]
#[of]:window
#[of]:class meta
window_cm_baseClass=screenManage
#[cf]
#[of]:static methods
function window.staticconstructor {
  typeset ${omv}method
#[of]:refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}objectId ${omv}left ${omv}top ${omv}width ${omv}height ${omv}parentFocusKey
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${omv}parentFocusKey=${q}${d}3${q}
    ${omv}focusedObject=${q}${d}4${q}
    
    ${o}.runEventAction refresh

    ((${ov}drawBorder)) && ${o}.drawBorder

    for ${omv}objectId in ${q}${d}{!${ov}objectNames[@]}${q} ; do
      ${omv}left=${d}{${ov}objectPositions[4*${omv}objectId+0]}
      ${omv}top=${d}{${ov}objectPositions[4*${omv}objectId+2]}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.getWidth ${omv}width
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.getHeight ${omv}height
      if (( (${omv}left+${omv}width) > ${ov}width || (${omv}top+${omv}height) > ${ov}height )) ; then
        die 1 ${q}${d}{${ov}objectNames[${d}{${omv}objectId}]} is out of bounds of ${o}${q}
      fi

      ${o}.setcursorxy ${q}${d}{${omv}left}${q} ${q}${d}{${omv}top}${q}
      ${d}{${ov}objectNames[${d}{${omv}objectId}]}.refresh \
        ${q}${d}((${ov}leftOffset+${omv}left))${q} \
        ${q}${d}((${ov}topOffset+${omv}top))${q} \
        ${q}${d}{${omv}parentFocusKey}_${d}{${ov}objectNames[${d}{${omv}objectId}]}${q} \
        ${q}${d}{${omv}focusedObject}${q}
    done
    ${o}.setcursorxy 1 1

    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:getEventAction {
IFS='' read -r -d '' ${omv}method <<'EOF'
getEventAction {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}mouseEvent ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentRelX ${omv}currentRelY ${omv}relX ${omv}relY
    typeset ${omv}objectName ${omv}objectId ${omv}action
#[c]    echo \"\$@\"
    ${omv}mouseEvent=${q}${d}{5}${q}
    ${omv}relX=${q}${d}{6}${q}
    ${omv}relY=${q}${d}{7}${q}

#[of]:    if not mouse event return self
    if [[ -z ${q}${d}{${omv}relX}${q} ]] ; then
      [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
      ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}{${omv}mouseEvent}${q}
      return
    fi
#[cf]

#[of]:    find object under current mouse position
    ${omv}mouseX=${d}{${omv}relX}
    ${omv}mouseY=${d}{${omv}relY}
    ${omv}objectName=${q}${q}

    ## this gets the keys from ${ov}objectNames and then loops through them in reverse
    ${omv}objectNamesKeys=( ${d}{!${ov}objectNames[@]} )
    for ((i=${d}{#${omv}objectNamesKeys[@]}-1;i>=0;i--));do
      ${omv}objectId=${q}${d}{${omv}objectNamesKeys[${d}{i}]}${q}
      if  (( ${ov}objectPositions[4*${omv}objectId+0] <= ${omv}mouseX &&
          ${omv}mouseX <= ${ov}objectPositions[${d}((4*${omv}objectId+1))] &&
         ${ov}objectPositions[4*${omv}objectId+2] <= ${omv}mouseY &&
         ${omv}mouseY <= ${ov}objectPositions[4*${omv}objectId+3] ))
      then
        ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q}
#[of]:        calculate relative position for found object
        ${omv}relX=${d}(( ${omv}mouseX - ${ov}objectPositions[4*${omv}objectId+0] ))
        ${omv}relY=${d}(( ${omv}mouseY - ${ov}objectPositions[4*${omv}objectId+2] ))
#[cf]
        break
      fi
    done
#[cf]
  
#[c]    ((gl_debug>0)) && 
#[c]    echo ${q}w - ${d}{!${ov}objectPositions[@]} | ${d}{${ov}objectPositions[@]} -- ${o}_${d}{${omv}objectName:---} ${d}{${omv}mouseEvent} ${d}{${omv}relX} ${d}{${omv}relY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}${q}

    if [[ -n ${q}${d}{${omv}objectName}${q} ]] ; then
#[of]:      query object under mouse for registered events
#[c]      echo ${d}{${omv}objectName}.getEventAction ${q}${d}1${q} ${q}${d}2${q} ${omv}currentRelX ${omv}currentRelY ${q}${d}{${omv}mouseEvent}${q} ${d}{${omv}relX} ${d}{${omv}relY} || return 1
      ${d}{${omv}objectName}.getEventAction ${q}${d}1${q} ${q}${d}2${q} ${omv}currentRelX ${omv}currentRelY ${q}${d}{${omv}mouseEvent}${q} ${d}{${omv}relX} ${d}{${omv}relY} || return 1
      [[ ${q}${d}3${q} != ${q}!${q} ]] && eval ${d}3=\\${q}\\${d}{${omv}currentRelX:-\\${d}{${omv}relX}}\\${q}
      [[ ${q}${d}4${q} != ${q}!${q} ]] && eval ${d}4=\\${q}\\${d}{${omv}currentRelY:-\\${d}{${omv}relY}}\\${q}
      return 0
#[cf]
    else
#[of]:      return self
      [[ ${q}${d}1${q} != ${q}!${q} ]] && eval ${d}1=\\${q}${o}\\${q}
      ${ov}inputEventActions.getkey ${q}${d}2${q} ${q}${d}{${omv}mouseEvent}${q}
      [[ ${q}${d}3${q} != ${q}!${q} ]] && eval ${d}3=\\${q}\\${d}{${omv}relX}\\${q}
      [[ ${q}${d}4${q} != ${q}!${q} ]] && eval ${d}4=\\${q}\\${d}{${omv}relY}\\${q}
#[cf]
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:focusList {
IFS='' read -r -d '' ${omv}method <<'EOF'
focusList {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}entry ${omv}objectId ${omv}objectName ${omv}focusListKey ${omv}focusList ${omv}focusListMerged
    typeset ${omv}parentFocusKey
    ${omv}parentFocusKey=${q}${d}2${q}

    for ${omv}focusListKey in ${q}${d}{${ov}focusList[@]}${q} ; do
      ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}focusListKey}]}${q}
      if isfnset ${d}{${omv}objectName}.focusList ; then
        ${d}{${omv}objectName}.focusList ${omv}focusList ${q}${d}{${omv}parentFocusKey}_${d}{${omv}objectName}${q}
        for ${omv}entry in ${q}${d}{${omv}focusList[@]}${q} ; do
          apush ${omv}focusListMerged ${q}${d}{${omv}entry}${q}
        done
      else
        apush ${omv}focusListMerged ${q}${d}{${omv}parentFocusKey}_${d}{${omv}objectName}${q}
      fi
    done

    aset ${d}1 ${q}${d}{${omv}focusListMerged[@]}${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function window.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    object data
newvar ${ov}objectPositions
new referenceid ${ov}objectIdPool

${o}.setWidth ${q}${d}{1:-0}${q}
${o}.setHeight ${q}${d}{2:-0}${q}

#[c]${ov}drawBorder=0
#[c]${ov}borderStyle=0

#[cf]
  "
}
#[cf]
#[cf]
#[c]
#[of]:screenObject
#[of]:description
#[c]screen object base class
#[cf]
#[of]:class meta
screenObject_cm_baseClass=screenCore
#[cf]
#[of]:static methods
function screenObject.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}hasFocus ${omv}length ${omv}index ${omv}line
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${o}.runEventAction refresh
    [[ -z ${q}${d}{${ov}topOffset}${q} ]] && return


    [[ -n ${q}${d}4${q} ]] && {
      [[ ${q}${d}3${q} = ${q}${d}4${q} ]] && ${ov}hasFocus=1 || ${ov}hasFocus=0
    }

    for ((${omv}index=0;${omv}index<${ov}height;${omv}index++)) ; do
      ${o}.setcursorxy 0 ${d}{${omv}index}
      printf ${q}%${d}((${ov}width))s${q} ${q}${q}
    done
      
    ((${ov}height>2)) && {
      ((${ov}drawBorder)) && ${o}.drawBorder
    }

    ((${ov}hasFocus)) && ${o}.styleSetReverse
    
    screen.stringLength ${omv}length ${q}${d}{${ov}title}${q}
    if ((${ov}txtAlignment)) ; then
      ${o}.setcursorxy 0 ${d}((${ov}height&1?${ov}height/2:${ov}height/2-1))
    else
      ${o}.setcursorxy ${d}((${ov}width/2-${d}{${omv}length}/2)) ${d}((${ov}height&1?${ov}height/2:${ov}height/2-1))
    fi
    echo -n ${q}${d}{${ov}title:0:${d}((${ov}width))}${q}

    ((${ov}hasFocus)) && ${o}.styleSetNormal
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function screenObject.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  public settable object data
  newPublicVar txtAlignment
#[cf]
  eval "
#[of]:    object data
newvar ${ov}hasFocus

${ov}txtAlignment=0
#[cf]
  "
}
#[cf]
#[cf]
#[of]:label
#[of]:class meta
label_cm_baseClass=screenObject
#[cf]
#[of]:dynamic methods
function label.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setTitle
m=setTitle
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}title=${q}${d}1${q}

  if ((${ov}width==0)) ; then
    if ((${ov}drawBorder)) && ((${ov}height>2)) ; then
      ${ov}width=${d}((${d}{#${ov}title}+4))
    else
      ${ov}width=${d}{#${ov}title}
    fi
  else
    screen.trimString ${ov}title ${d}{${ov}width} ${q}${d}{${ov}title}${q}
  fi
}"
#[cf]
  eval "
#[of]:    object data

#[cf]
  "
}
#[cf]
#[cf]
#[of]:button
#[of]:class meta
button_cm_baseClass=label
#[cf]
#[of]:dynamic methods
function button.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
#[of]:    object data
${ov}drawBorder=1
${ov}borderStyle=1
#[cf]
  "
}
#[cf]
#[cf]
#[of]:sliderBar
#[of]:class meta
sliderBar_cm_baseClass=screenObject
#[cf]
#[of]:static methods
function sliderBar.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}sliderLength ${omv}songLength ${omv}songTimePlayed
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${o}.runEventAction refresh
    [[ -z ${q}${d}{${ov}topOffset}${q} ]] && return


    [[ -n ${q}${d}4${q} ]] && {
      [[ ${q}${d}3${q} = ${q}${d}4${q} ]] && ${ov}hasFocus=1 || ${ov}hasFocus=0
    }

    if ((${ov}hasFocus)) ; then
      ${omv}h='~'
      ${omv}v='||'
    else
      ${omv}h='-'
      ${omv}v='::'
    fi
    ${omv}t='/\\\\'
    ${omv}b='\\\\/'
    
    ## set position only if not a direct sub-class call
    [ ${q}${c}${q} != ${q}${smc}${q} ] && {
      typeset ${omv}sliderPositionPercentage
      if isset ${ov}positionUpdater && isfnset ${q}${d}{${ov}positionUpdater}${q} ; then
        ${d}{${ov}positionUpdater} ${q}${omv}sliderPositionPercentage${q}
      else
        ${omv}sliderPositionPercentage=50
      fi
    }

    ${o}.setcursorxy 0 0
    if ((${ov}width>${ov}height)) ; then
      ${omv}sliderLength=${d}((${ov}sliderLength-3))

      echo -n ${q}<${q}
      printf -v ${omv}line ${q}%${d}(( ${omv}sliderPositionPercentage*${omv}sliderLength/100 ))s${q} ${q}${q}
      echo -en ${q}${d}{${omv}line// /${d}{${omv}h}}${q}
  
      echo -n ${q}${d}(printf '%02d%%' ${q}${d}{${omv}sliderPositionPercentage#0}${q})${q}
  
      printf -v ${omv}line ${q}%${d}(( ${omv}sliderLength-(${omv}sliderPositionPercentage*${omv}sliderLength/100) ))s${q} ${q}${q}
      echo -en ${q}${d}{${omv}line// /${d}{${omv}h}}${q}
      echo -n ${q}>${q}
    else
      ${omv}sliderLength=${d}((${ov}sliderLength-1))

      echo -en ${q}${d}{${omv}t}\\\\e[D\\\\e[D\\\\e[B${q}
      printf -v ${omv}line ${q}%${d}(( ${omv}sliderPositionPercentage*${omv}sliderLength/100 ))s${q} ${q}${q}
      echo -en ${q}${d}{${omv}line// /${d}{${omv}v}\\\\e[D\\\\e[D\\\\e[B}${q}
  
#[c]      echo -en ${q}${d}{${omv}b}\\\\e[D\\\\e[D\\\\e[B${q}
      if [[ ${q}${d}{${omv}sliderPositionPercentage#0}${q} = 100 ]] ; then
        echo -en ${q}^^\\\\e[D\\\\e[D\\\\e[B${q}
      else
        echo -en ${q}${d}(printf '%02d' ${q}${d}{${omv}sliderPositionPercentage#0}${q})\\\\e[D\\\\e[D\\\\e[B${q}
      fi
#[c]      echo -en ${q}${d}{${omv}t}\\\\e[D\\\\e[D\\\\e[B${q}
  
      printf -v ${omv}line ${q}%${d}(( ${omv}sliderLength-(${omv}sliderPositionPercentage*${omv}sliderLength/100) ))s${q} ${q}${q}
      echo -en ${q}${d}{${omv}line// /${d}{${omv}v}\\\\e[D\\\\e[D\\\\e[B}${q}
      echo -en ${q}${d}{${omv}b}${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  buildSlider {
IFS='' read -r -d '' ${omv}method <<'EOF'
buildSlider {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}h ${omv}v  ${omv}tl_br ${omv}tr_bl

    ${omv}h='-'
    ${omv}v='|'
    ${omv}tl_br='/'
    ${omv}tr_bl='\'

    if ((${ov}width>${ov}height)) ; then
      printf -v ${ov}sliderFilled %${d}((${ov}width-2))s ${q}${q}
      ${ov}sliderLength=${d}{#${ov}sliderFilled}

      ${ov}sliderErase=${q}${d}{${ov}sliderFilled// /\\\\b}\\b\\b${q}
      ${ov}sliderFocused=${q}${d}{${ov}sliderFilled// /\\~}${q}
      ${ov}sliderFilled=${q}${d}{${ov}sliderFilled// /-}${q}
    else
      printf -v ${ov}sliderFilled %${d}((${ov}height-2))s ${q}${q}
      ${ov}sliderLength=${d}{#${ov}sliderFilled}

      ${ov}sliderErase=${q}${d}{${ov}sliderFilled// /\\\\e[B\\\\e[D\\\\b}${q}
      ${ov}sliderFocused=${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}
      ${ov}sliderFilled=${q}${d}{${omv}line// /\\\\e[B\\\\e[D${d}{${omv}v}}${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function sliderBar.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setWidth
m=setWidth
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}width=${q}${d}1${q}
  ${o}.buildSlider
}"
#[cf]
#[of]:  setHeight
m=setHeight
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}height=${q}${d}1${q}
  ${o}.buildSlider
}"
#[cf]
#[of]:  public settable object data
  newPublicVar positionUpdater
#[cf]
  eval "
#[of]:    object data
newvar ${ov}sliderFilled ${ov}sliderErase ${ov}sliderFocused ${ov}sliderLength

${ov}width=${q}${d}{1:-20}${q}
${ov}height=${q}${d}{2:-1}${q}
#[cf]
    ${o}.buildSlider
  "
}
#[cf]
#[cf]
#[of]:listBox
#[of]:description
#[c]if this class is being used as a regular (not a base or a sub) class then the list
#[c]  must be updated with a list updater method in the main program
#[c]
#[c]{objectname}.setListUpdater fillmylist
#[c]function fillmylist {
#[c]  local -n myentryList="$1"
#[c]  myentryList=( yes "sample 1" "sample 2" "sample 3" "sample 4" )
#[c]}

#[cf]
#[of]:class meta
listBox_cm_baseClass=screenObject
#[cf]
#[of]:static methods
function listBox.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}index
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${o}.runEventAction refresh
    [[ -z ${q}${d}{${ov}topOffset}${q} ]] && return


    for ((${omv}index=${ov}entryListIndexOffset;${omv}index<${ov}height+${ov}entryListIndexOffset;${omv}index++)) ; do
#[of]:      erase line
      ${o}.setcursorxy 0 ${d}((${omv}index-${ov}entryListIndexOffset))
      printf ${q}%${d}((${ov}width))s${q} ${q}${q}
#[cf]
#[of]:      print line
      if [[ -n ${q}${d}{${ov}indexLookupTable[${d}{${omv}index}]}${q} ]] ; then
        ${o}.setcursorxy 0 ${d}((${omv}index-${ov}entryListIndexOffset))
  
        ((${ov}selectedEntry==${d}{${ov}indexLookupTable[${d}{${omv}index}]})) && ${o}.styleSetReverse
        echo -n ${q} ${d}{${ov}entryListTrimmed[${d}{${ov}indexLookupTable[${d}{${omv}index}]}]}${q}
        ((${ov}selectedEntry==${d}{${ov}indexLookupTable[${d}{${omv}index}]})) && ${o}.styleSetNormal
      fi
#[cf]
    done
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  updateList {
IFS='' read -r -d '' ${omv}method <<'EOF'
updateList {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}entry

    ## fill list only if not a direct sub-class call
    [ ${q}${c}${q} != ${q}${smc}${q} ] && {
      if isset ${ov}listUpdater && isfnset ${q}${d}{${ov}listUpdater}${q} ; then
        ${d}{${ov}listUpdater} ${q}${ov}entryList${q}
      fi
    }

    ## trim the list only if buildTrimmedEntryList (default)=true
    ${d}{${ov}buildTrimmedEntryList} && {
      unset ${ov}entryListTrimmed
      for ${omv}entry in ${q}${d}{${ov}entryList[@]}${q} ; do
        screen.trimString ${omv}entry ${d}((${ov}width-2)) ${q}${d}{${omv}entry}${q}
        apush ${ov}entryListTrimmed ${q}${d}{${omv}entry}${q}
      done
    }

    ((${d}{#${ov}entryList[@]}>0)) && eval ${q}${ov}indexLookupTable=( {0..${d}((${d}{#${ov}entryList[@]}-1))} )${q}
    ${ov}indexLookupTableReversed=( ${q}${d}{${ov}indexLookupTable[@]}${q} )

    ${ov}entryListIndexOffset=0
    ${ov}selectedEntry=0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  selectListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
selectListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}index ${omv}found
    ${omv}found=0

    if isnum ${q}${d}1${q} ; then
      if [[ -n ${q}${d}{${ov}indexLookupTable[${d}((${ov}entryListIndexOffset+${d}1))]}${q} ]] ; then
        ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}((${ov}entryListIndexOffset+${d}1))]}
      else
        return 1
      fi
    elif [[ -n ${q}${d}{1}${q} ]] ; then
      for ${omv}index in ${q}${d}{!${ov}entryList[@]}${q} ; do
        [[ ${q}${d}{${ov}entryList[${d}{${omv}index}]}${q} = ${q}${d}{1}${q} ]] && {
          ${ov}selectedEntry=${d}{${omv}index}
          ${omv}found=1
          break
        }
      done
      ((${omv}found)) || return 1
      for ((${ov}entryListIndexOffset=0;${ov}entryListIndexOffset<${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]+1-${ov}height;${ov}entryListIndexOffset+=${ov}height)) ; do :;done
    fi
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  incSelectedListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
incSelectedListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}>=${d}{#${ov}entryList[@]}-1)) ; then
      ${ov}selectedEntry=${d}{${ov}indexLookupTable[0]}
      ${ov}entryListIndexOffset=0
    else
      ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}+1))]}
    fi

    ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}-${ov}entryListIndexOffset>${ov}height-1)) && ${o}.pageDown
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  decSelectedListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
decSelectedListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}==0)) ; then
      ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}((${d}{#${ov}entryList[@]}-1))]}
      for ((${ov}entryListIndexOffset=0;${ov}entryListIndexOffset<${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}-${ov}height-1;${ov}entryListIndexOffset=${ov}entryListIndexOffset+${ov}height)) do :; done
    else
      ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}-1))]}
    fi

    ((${d}{${ov}indexLookupTableReversed[${d}{${ov}selectedEntry}]}<${ov}entryListIndexOffset)) && {
      ${o}.pageUp
      ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}((${ov}entryListIndexOffset+${ov}height-1))]}
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  getSelectedListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
getSelectedListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
      echo ${q}${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q}
    else
      eval ${d}1=\\${q}\\${d}{${ov}entryList[\\${d}{${ov}selectedEntry}]}\\${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  getPagePercentage {
IFS='' read -r -d '' ${omv}method <<'EOF'
getPagePercentage {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}percentage
    if (( ${ov}entryListIndexOffset+${ov}height>${d}{#${ov}entryList[@]} )) ; then
      ${omv}percentage=100
    else
      ${omv}percentage=${d}(( 100*${ov}entryListIndexOffset/${d}{#${ov}entryList[@]} ))
    fi
#[c]    echo ${d}{${ov}entryListIndexOffset} ${d}{#${ov}entryList[@]} ${d}{${ov}height}

    if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
      echo ${d}{${omv}percentage}
    else
      eval ${q}${d}1=\\${d}{${omv}percentage}${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[c]
#[c]((${ov}entryListIndexOffset<${d}{#${ov}entryList[@]}-${ov}height))
#[c]
#[c]$((100*(${ov}entryListIndexOffset+${ov}height)/${d}{#${ov}entryList[@]}))
#[c]${ov}entryList
#[c]${ov}height
#[c]
#[cf]
#[of]:  setEntryList {
IFS='' read -r -d '' ${omv}method <<'EOF'
setEntryList {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ${ov}entryList=( ${q}${d}@${q} )
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function listBox.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  listLookupShuffle
m=listLookupShuffle
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${d}{#${ov}entryList[@]}>0)) && ${ov}indexLookupTable=( ${d}(eval ${q}shuf -e {0..${d}((${d}{#${ov}entryList[@]}-1))}${q}) )

  unset ${ov}indexLookupTableReversed
  for _i in ${q}${d}{${ov}indexLookupTable[@]}${q};do ${ov}indexLookupTableReversed[${d}{_i}]=${d}{#${ov}indexLookupTableReversed[@]};done
  
  ${ov}entryListIndexOffset=0
  ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}{${ov}entryListIndexOffset}]}
}"
#[cf]
#[of]:  listLookupReset
m=listLookupReset
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${d}{#${ov}entryList[@]}>0)) && eval ${q}${ov}indexLookupTable=( {0..${d}((${d}{#${ov}entryList[@]}-1))} )${q}
  ${ov}indexLookupTableReversed=( ${q}${d}{${ov}indexLookupTable[@]}${q} )

  ${ov}entryListIndexOffset=0
  ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}{${ov}entryListIndexOffset}]}
}"
#[cf]
#[of]:  pageUp
m=pageUp
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}entryListIndexOffset>0)) && ((${ov}entryListIndexOffset=${ov}entryListIndexOffset-${ov}height))
  ((${ov}entryListIndexOffset<0)) && ${ov}entryListIndexOffset=0
  ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}{${ov}entryListIndexOffset}]}
}"
#[cf]
#[of]:  pageDown
m=pageDown
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ((${ov}entryListIndexOffset<${d}{#${ov}entryList[@]}-${ov}height)) && ((${ov}entryListIndexOffset=${ov}entryListIndexOffset+${ov}height))
  ${ov}selectedEntry=${d}{${ov}indexLookupTable[${d}{${ov}entryListIndexOffset}]}
}"
#[cf]
#[of]:  public settable object data
  newPublicVar listUpdater
#[cf]
  eval "
#[of]:    object data
newvar ${ov}entryList ${ov}entryListTrimmed ${ov}entryListIndexOffset ${ov}indexLookupTable
newvar ${ov}selectedEntry

newvar ${ov}buildTrimmedEntryList

${ov}buildTrimmedEntryList=true

if [[ ${q}${c}${q} = ${q}listBox${q} ]] ; then
  if ((${d}#>2)) ; then
    ${ov}entryList=( ${q}${d}{@:3}${q} )
  else
    ## default entries for new object with undefined list
    ${ov}entryList=( ${q}need to set a ListUpdater method${q} ${q}or call the setEntryList method${q} ${q}sample 1${q} ${q}sample 2${q} ${q}sample 3${q} ${q}sample 4${q} )
  fi
  ${o}.updateList
fi

#[cf]
#[c]    ${o}.updateList
  "
}
#[cf]
#[cf]
#[of]:textBox
#[of]:class meta
textBox_cm_baseClass=screenObject
#[cf]
#[of]:static methods
function textBox.staticconstructor {
  typeset ${omv}method
#[of]:  open {
IFS='' read -r -d '' ${omv}method <<'EOF'
open {
#[c]object -|var
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}key ${omv}mouse
    typeset ${omv}mouseEvent ${omv}mouseEvents ${omv}mouseButtonId ${omv}mouseButtonName
    typeset ${omv}mouseXStart ${omv}mouseYStart ${omv}mouseX ${omv}mouseY
    typeset ${omv}currentRelX ${omv}currentRelY ${omv}relX ${omv}relY
    typeset ${omv}mouseButtonState ${omv}shift ${omv}alt ${omv}ctrl
    typeset ${omv}objectNamesKeys
    typeset ${omv}objectName ${omv}objectId
    typeset ${omv}triggerId

    ${omv}refreshInterval=${q}${d}{${ov}refreshInterval}${q}

    ${o}.calcScreenSize
    ${o}.focusListBuild
    ${o}.focusTriggerFocusEvent enter
    clear
    ${o}.refresh
    ${c}.mouseEnable -d
#[of]:    key process loop
    while : ; do
      ((${ov}flagExit)) && {
        ${ov}flagExit=0
        break
      }
      read -s -N 1 -r ${d}{${ov}tickIntervalSeconds:+-t ${d}{${ov}tickIntervalSeconds}} ${omv}key || {
        ((${ov}tick+=1))
        ((${ov}tick>${ov}tickMax)) && ${ov}tick=0

        for ${omv}triggerId in ${q}${d}{!${ov}timerTriggerIdList[@]}${q} ; do
          ((${ov}tick%${ov}tickTriggers[${d}((${omv}triggerId*3))]==0)) && {
            ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+1))]}.runEventAction ${d}{${ov}tickTriggers[${d}((${omv}triggerId*3+2))]}
          }
        done

        ((${ov}refreshInterval>0)) && ((${ov}tick%${ov}refreshInterval==0)) && ${o}.refresh
      }
      case ${q}${d}{${omv}key}${q} in
#[of]:        escaped keys
        ${d}'\e')
          read -s -N 2 -r -t .1 ${omv}key || {
#[of]:            esc
#[c]            esc itself is just a single char
#[c]            if read timeout is reached the key must be esc
            ${omv}key=esc
            ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
            ${o}.processEvent \
              ${q}${d}{${omv}objectName}${q} \
              ${q}${d}{${omv}key}${q} \
              0 0 \
              0 0 || \
            echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
            continue
#[cf]
          }
          [[ ${q}${d}{${omv}key}${q} == '[1' ]] && read -s -N 3 -r -t .1 ${omv}key
          case ${q}${d}{${omv}key}${q} in
#[of]:            mouse
            '[<')
#[of]:              read mouse input strings from terminal
              ${omv}mouseButtonId=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseButtonId=${q}${d}{${omv}mouseButtonId}${d}{${omv}key}${q}
              done
              ${omv}mouseX=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [[ ${q}${d}{${omv}key}${q} == ${q};${q} ]] && break
                ${omv}mouseX=${q}${d}{${omv}mouseX}${d}{${omv}key}${q}
              done
              ${omv}mouseY=${q}${q}
              while read -s -N 1 -r ${omv}key ; do
                [ -z ${q}${d}{${omv}key#[Mm]}${q} ] && break
                ${omv}mouseY=${q}${d}{${omv}mouseY}${d}{${omv}key}${q}
              done
              [[ ${q}${d}{${omv}key}${q} == ${q}M${q} ]] && ${omv}mouseButtonState=${q}Down${q} || ${omv}mouseButtonState=${q}Up${q}
              ((${omv}mouseX--))
              ((${omv}mouseY--))
#[cf]
#[of]:              decode mouse input into event tags

#[c]              left middle right scroll_Up scroll_Down
#[c]              shift alt ctrl

              (( (${omv}mouseButtonId & 4 )==4  )) && ${omv}shift=${q}Shift${q} || ${omv}shift=${q}${q}
              (( (${omv}mouseButtonId & 8 )==8  )) && ${omv}alt=${q}Alt${q}     || ${omv}alt=${q}${q}
              (( (${omv}mouseButtonId & 16)==16 )) && ${omv}ctrl=${q}Ctrl${q}   || ${omv}ctrl=${q}${q}
              (( (${omv}mouseButtonId & 32)==32 )) && ${omv}mouseButtonState=${q}Drag${q}
              case ${q}${d}((${omv}mouseButtonId & 67))${q} in
                 0) ${omv}mouseButtonName=${q}Left${q}   ;;&
                 1) ${omv}mouseButtonName=${q}Middle${q} ;;&
                 2) ${omv}mouseButtonName=${q}Right${q}  ;;&
                64) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Up${q}    ;;
                65) ${omv}mouseButtonName=${q}Scroll${q}
                    ${omv}mouseButtonState=${q}Down${q}  ;;
                 *) case ${q}${d}{${omv}mouseButtonState}${q} in
                      Down)
                        ${ov}previousMouseButtonName=${q}${d}{${omv}mouseButtonName}${q}
                        ${ov}previousMouseX=${q}${d}{${omv}mouseX}${q}
                        ${ov}previousMouseY=${q}${d}{${omv}mouseY}${q}
                        ;;
                      Up)
                        [[  ${q}${d}{${ov}previousMouseButtonName}${q} = ${q}${d}{${omv}mouseButtonName}${q} &&
                            ${q}${d}{${ov}previousMouseX}${q} = ${q}${d}{${omv}mouseX}${q} &&
                            ${q}${d}{${ov}previousMouseY}${q} = ${q}${d}{${omv}mouseY}${q} ]] && \
                          aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}Click${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}
                        ;;
                    esac
                    ;;
              esac
              aunshift ${omv}mouseEvents ${q}mouse${d}{${omv}mouseButtonName}${d}{${omv}mouseButtonState}${d}{${omv}shift}${d}{${omv}alt}${d}{${omv}ctrl}${q}
#[cf]

#[c]              object on screen has TOPxLEFT and WIDTHxHEIGHT
#[c]                button Down event
#[c]                  -if xy no longer on the current object it is a drag-drop operation
#[c]                  setCurrentScreenObject buttonID/textBoxID/windowID/etc...
#[c]                  screen.objectID.sendEvent mouse_Left_Down x-left y-top
#[c]                button Up event
#[c]                  screen.objectID.sendEvent mouse_Left_Up objectID sx-left sy-top x-left y-top
#[c]                
#[c]              
#[c]              for objectID in screen_objects do
#[c]                if top<y<top+height && left<x<left+width ; then
#[c]                  if [[ ${q}${d}{${omv}mouseButtonName}${q} == ${q}scroll${q} || ${q}${d}{${omv}mouseButtonState}${q} == ${q}Down${q} ]] && setCurrentScreenObject=${objectID}
#[c]                  screen.sendEvent objectID mouse_Left_Down x-left y-top
#[c]                  break
#[c]                fi
#[c]              done

#[of]:              find object under current mouse position
              ${omv}relX=${d}{${omv}mouseX}
              ${omv}relY=${d}{${omv}mouseY}
              ${omv}objectName=${q}${q}

              ## this gets the keys from ${ov}objectNames and then loops through them in reverse
              ${omv}objectNamesKeys=( ${d}{!${ov}objectNames[@]} )
              for ((i=${d}{#${omv}objectNamesKeys[@]}-1;i>=0;i--));do
                ${omv}objectId=${q}${d}{${omv}objectNamesKeys[${d}{i}]}${q}
                if  (( ${ov}objectPositions[4*${omv}objectId+0] <= ${omv}mouseX &&
                    ${omv}mouseX <= ${ov}objectPositions[${d}((4*${omv}objectId+1))] &&
                   ${ov}objectPositions[4*${omv}objectId+2] <= ${omv}mouseY &&
                   ${omv}mouseY <= ${ov}objectPositions[4*${omv}objectId+3] ))
                then
                  ${omv}objectName=${q}${d}{${ov}objectNames[${d}{${omv}objectId}]}${q}
#[of]:                  calculate relative position for found object
                  ${omv}relX=${d}(( ${omv}mouseX - ${ov}objectPositions[4*${omv}objectId+0] ))
                  ${omv}relY=${d}(( ${omv}mouseY - ${ov}objectPositions[4*${omv}objectId+2] ))
#[cf]
                  break
                fi
              done
#[cf]

#[c]###write some code that disables event actions and just shows mouse events
#[c]###be sure the code shows screen object calls as well
              ((gl_debug>0)) && echo ${q}s - ${d}{!${ov}objectPositions[@]} | ${d}{${ov}objectPositions[@]} -- ${d}{${omv}objectName:-${o}} ${d}{${omv}mouseEvent} ${d}{${omv}relX} ${d}{${omv}relY} ${d}{${omv}mouseX} ${d}{${omv}mouseY}${q}

#[of]:              process mouse event queue list
              while ashift ${omv}mouseEvent ${omv}mouseEvents ; do
                ${o}.processEvent \
                  ${q}${d}{${omv}objectName:-${o}}${q} \
                  ${q}${d}{${omv}mouseEvent}${q} \
                  ${q}${d}{${omv}relX}${q} ${q}${d}{${omv}relY}${q} \
                  ${q}${d}{${omv}mouseX}${q} ${q}${d}{${omv}mouseY}${q}
              done
#[cf]
              ;;
#[cf]
#[of]:            shift up)
            '[a'|';2A')
              ${omv}key=shiftUp
              ;;&
#[cf]
#[of]:            shift down)
            '[b'|';2B')
              ${omv}key=shiftDown
              ;;&
#[cf]
#[of]:            shift left)
            '[d'|';2D')
              ${omv}key=shiftLeft
              ;;&
#[cf]
#[of]:            shift right)
            '[c'|';2C')
              ${omv}key=shiftRight
              ;;&
#[cf]
#[of]:            alt up)
            ';3A')
              ${omv}key=altUp
              ;;&
#[cf]
#[of]:            alt down)
            ';3B')
              ${omv}key=altDown
              ;;&
#[cf]
#[of]:            alt left)
            ';3D')
              ${omv}key=altLeft
              ;;&
#[cf]
#[of]:            alt right)
            ';3C')
              ${omv}key=altRight
              ;;&
#[cf]
#[of]:            ctrl up)
            ';5A')
              ${omv}key=ctrlUp
              ;;&
#[cf]
#[of]:            ctrl down)
            ';5B')
              ${omv}key=ctrlDown
              ;;&
#[cf]
#[of]:            ctrl left)
            ';5D')
              ${omv}key=ctrlLeft
              ;;&
#[cf]
#[of]:            ctrl right)
            ';5C')
              ${omv}key=ctrlRight
              ;;&
#[cf]
#[of]:            up)
            '[A')
              ${omv}key=up
              ;;&
#[cf]
#[of]:            down)
            '[B')
              ${omv}key=down
              ;;&
#[cf]
#[of]:            left)
            '[D')
              ${omv}key=left
              ;;&
#[cf]
#[of]:            right)
            '[C')
              ${omv}key=right
              ;;&
#[cf]
#[of]:            shift tab)
            '[Z')
              ${omv}key=shiftTab
              ;;&
#[cf]
#[of]:            page up)
            '[5')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageUp
              ;;&
#[cf]
#[of]:            page down)
            '[6')
              read -s -N 1 -r ${omv}key
              [[ ${q}${d}{${omv}key}${q} = '~' ]] && ${omv}key=pageDown
              ;;&
#[cf]
#[of]:            *)
            *)
              ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
              ${o}.processEvent \
                ${q}${d}{${omv}objectName}${q} \
                ${q}${d}{${omv}key}${q} \
                0 0 \
                0 0 || \
              echo ${q}ascii ---${d}{${omv}key}---esc---${d}{${omv}objectName:-${o}}${q}
              ;;
#[cf]
          esac
          ;;
#[cf]
#[of]:        enter)
        '
')
          ${omv}key=enter
          ;;&
#[cf]
#[of]:        tab)
        '	')
          ${omv}key=tab
          ;;&
#[cf]
#[of]:        tick)
        '')
          ;;
#[cf]
#[of]:        *)
        *)
          ${ov}inputEventActions.getkey ! ${q}${d}{${omv}key}${q} && ${omv}objectName=${o} || ${omv}objectName=${q}${d}{${ov}focusListMerged[${d}{${ov}focusedObjectIndex}]##*_}${q}
          ${o}.processEvent \
            ${q}${d}{${omv}objectName}${q} \
            ${q}${d}{${omv}key}${q} \
            0 0 \
            0 0 || \
          echo ${q}ascii ---${d}{${omv}key}---chr---${d}{${omv}objectName:-${o}}${q}
          ;;
#[cf]
      esac
    done
#[cf]
    ${c}.mouseDisable

    clear
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}hasFocus ${omv}length ${omv}index ${omv}line
    [[ -n ${q}${d}{2}${q} ]] && {
      ${ov}leftOffset=${q}${d}{1}${q}
      ${ov}topOffset=${q}${d}{2}${q}
    }
    ${o}.runEventAction refresh
    [[ -z ${q}${d}{${ov}topOffset}${q} ]] && return


    [[ -n ${q}${d}4${q} ]] && {
      [[ ${q}${d}3${q} = ${q}${d}4${q} ]] && ${ov}hasFocus=1 || ${ov}hasFocus=0
    }

    ((${ov}height>2)) && {
      for ((${omv}index=0;${omv}index<${ov}height;${omv}index++)) ; do
        ${o}.setcursorxy 0 ${d}{${omv}index}
        printf ${q}%${d}((${ov}width))s${q} ${q}${q}
      done
      
      ((${ov}drawBorder)) && ${o}.drawBorder
    }

    ((${ov}hasFocus)) && ${o}.styleSetReverse
    
    screen.stringLength ${omv}length ${q}${d}{${ov}title}${q}
#[c]    ${o}.setcursorxy 0 ${d}((${ov}height/2))
#[c]    printf ${q}%${d}((${ov}width))s${q} ${q}${q}
    if ((${ov}txtAlignment)) ; then
      ${o}.setcursorxy 0 ${d}((${ov}height&1?${ov}height/2:${ov}height/2-1))
    else
      ${o}.setcursorxy ${d}((${ov}width/2-${d}{${omv}length}/2)) ${d}((${ov}height&1?${ov}height/2:${ov}height/2-1))
    fi
    echo -n ${q}${d}{${ov}title:0:${d}((${ov}width))}${q}

    ((${ov}hasFocus)) && ${o}.styleSetNormal
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[c]
#[c]without focus just draw box
#[c]with focus
#[c]  start read loop
#[c]    check for exit key/s or mouse click outside of box
#[c]    all other keys are captured and added into the txtBox buffer
#[c]
#[c]forward mouse clicks to screen, how??
#[c]any click outside of box loses focus
#[c]  focus doesn't have to go anywhere, but can't stay here
#[cf]
}
#[cf]
#[of]:dynamic methods
function textBox.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  setTitle
m=setTitle
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${ov}title=${q}${d}1${q}

  if ((${ov}width==0)) ; then
    if ((${ov}drawBorder)) && ((${ov}height>2)) ; then
      ${ov}width=${d}((${d}{#${ov}title}+4))
    else
      ${ov}width=${d}{#${ov}title}
    fi
  else
    screen.trimString ${ov}title ${d}{${ov}width} ${q}${d}{${ov}title}${q}
  fi
}"
#[cf]
  eval "
#[of]:    object data

#[cf]
  "
}
#[cf]
#[cf]
#[c]
#[of]:browserBoxFile
#[of]:class meta
browserBoxFile_cm_baseClass=listBox
#[cf]
#[of]:static methods
function browserBoxFile.staticconstructor {
  typeset ${omv}method
#[of]:  refresh {
IFS='' read -r -d '' ${omv}method <<'EOF'
refresh {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    [[ -z ${q}${d}{${ov}pwd}${q} ]] && ${o}.setPwd

    ${d}{${cm}baseClass}.${m} ${o} ${q}${d}@${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  updateList {
IFS='' read -r -d '' ${omv}method <<'EOF'
updateList {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}IFS

    ${omv}IFS=${q}${d}{IFS}${q}
    IFS=${d}'\\n'
    ${ov}entryList=( ${d}( cd ${q}${d}{${ov}pwd}${q};{ find . -maxdepth 1 -type d | sort;find . -maxdepth 1 -type f | sort; } | grep -oP '^\\./\\K.*') )
    IFS=${q}${d}{${omv}IFS}${q}

    ${d}{${cm}baseClass}.${m} ${o} ${q}${d}@${q}
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  selectListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
selectListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    ${d}{${cm}baseClass}.${m} ${o} ${q}${d}@${q} || return ${d}?

    [[ ${q}${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q} = ${q}..${q} ]] && {
      ${o}.movePwdUp
      return 1
    }
    [[ -d ${q}${d}{${ov}pwd}/${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q} ]] && {
      ${ov}pwd=${q}${d}{${ov}pwd%/}/${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q}
      ${o}.updateList
      return 1
    }
    
    return 0
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  getSelectedListEntry {
IFS='' read -r -d '' ${omv}method <<'EOF'
getSelectedListEntry {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
      echo ${q}${d}{${ov}pwd}/${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q}
    else
      eval ${d}1=\\${q}\\${d}{${ov}pwd}/\\${d}{${ov}entryList[\\${d}{${ov}selectedEntry}]}\\${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  getSelectedListEntryName
IFS='' read -r -d '' ${omv}method <<'EOF'
getSelectedListEntryName {
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    if [[ ${q}${d}1${q} = ${q}-${q} ]] ; then
      echo ${q}${d}{${ov}entryList[${d}{${ov}selectedEntry}]}${q}
    else
      eval ${d}1=\\${q}\\${d}{${ov}entryList[\\${d}{${ov}selectedEntry}]}\\${q}
    fi
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
#[of]:  setPwd {
IFS='' read -r -d '' ${omv}method <<'EOF'
setPwd {
#[c]object
#[of]:  set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
  eval "
    typeset ${omv}newPwd
    ${omv}newPwd=${q}${d}{1}${q}
    [[ ${d}{#${omv}newPwd} -gt 1 ]] && ${omv}newPwd=${q}${d}{${omv}newPwd%/}${q}
  
    [[ -z ${q}${d}{${omv}newPwd}${q} ]] && ${omv}newPwd=${q}${d}(pwd)${q}
    
    [[ ${q}${d}{${ov}pwd}${q} != ${q}${d}{${omv}newPwd}${q} ]] && {
      if [[ -d ${q}${d}{${omv}newPwd}${q} ]] ; then
        ${ov}pwd=${q}${d}{${omv}newPwd}${q}
      else
        ${ov}pwd=${d}(pwd)
      fi
      ${o}.updateList
    }
  "
}
EOF
eval "eval \"function \${c}.\${${omv}method}\""
#[cf]
}
#[cf]
#[of]:dynamic methods
function browserBoxFile.constructor {
#[of]:set common environment
#[l]:classcommonenv.sh:/usr/lib/objectsh-1/common/classcommonenv.sh
  . ${gl_classpath}/classcommonenv.sh
#[cf]
#[of]:  movePwdUp
m=movePwdUp
omv=${o}_mv_${m}_
eval "function ${o}.${m} {
  ${o}.setPwd ${q}${d}(cd ${q}${d}{${ov}pwd}/..${q};pwd)${q}
}"
#[cf]
#[of]:  public settable object data
  newPublicVar pwd
#[cf]
  eval "
#[of]:    object data
(($#>2)) && ${o}.setPwd ${q}${d}{3:-${d}(pwd)}${q}

#[cf]
#[c]    ${o}.updateList
  "
}
#[cf]
#[cf]
# vim:number:tabstop=2:shiftwidth=2:autoindent:foldmethod=marker:foldlevel=0:foldmarker=#[of]\:,#[cf]
